<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐风技术博客</title>
  
  
  <link href="/public/atom.xml" rel="self"/>
  
  <link href="https://blog.mufeng.tech/public/"/>
  <updated>2020-09-10T08:14:25.501Z</updated>
  <id>https://blog.mufeng.tech/public/</id>
  
  <author>
    <name>沐风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL的crash-safe的原理</title>
    <link href="https://blog.mufeng.tech/public/2020/09/10/MySQL%E7%9A%84crash-safe%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.mufeng.tech/public/2020/09/10/MySQL%E7%9A%84crash-safe%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2020-09-10T08:14:08.000Z</published>
    <updated>2020-09-10T08:14:25.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的crash-safe的原理"><a href="#MySQL的crash-safe的原理" class="headerlink" title="MySQL的crash-safe的原理"></a>MySQL的crash-safe的原理</h1><h3 id="组件分为"><a href="#组件分为" class="headerlink" title="组件分为"></a>组件分为</h3><ul><li>连接器</li><li>分析器</li><li>优化器</li><li>执行器</li><li>存储引擎（插件的形式）</li></ul><p>前面的四个分别是Server层的组件，后面存储引擎层是插件，如InnoDB，MyISAM，Memory等</p><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>连接器的作用主要是维持和客户端之间的通信功能。同时还负责同客户端的认证和授权的功能。</p><p>每个连接在完成认证和授权后就会一直维持一个长连接，创建完连接的后的所有通信都不需要进行再次进行认证，但每次SQL请求操作都会有权限的认证</p><p>在连接完成后，如果连接长时间没有SQL请求通信，该连接会处于Sleep状态，直到超过MySQL实例配置的<code>wait_timeout</code>参数的时间后，连接器会主动断开该长连接。MySQL实例默认的<code>wait_timeout</code>的的时间是8小时</p><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>分析器的执行分为两个过程，一个是词法分析，另一个是语法分析</p><p>我们发送的SQL语句是一个字符串，里面可能存在空格和字符串。词法分析器的作用就是把这个字符串代表的意思进行数据的格式化，比如<code>SELECT</code>子串标识这是一个读请求，<code>FROM t_table</code>表示要操作t_table这张表</p><p>语法分析的作用是要对这个语法的正确性做一个检查，如果当前的SQL语法不符合MySQL的语法，那么就直接报错了，不进行下一步的执行</p><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>优化器的作用是根据分析器得出的结果再结合当前表数据的储存情况来的出一个查询效率最高的执行计划。常见的情况有“：</p><ol><li>同一个SQL语句中存在多个索引列条件，那么应该先选择哪个索引先进行查询</li><li>多表join操作的时候，如何选择哪个表作为驱动表等</li></ol><p>上面两种情况都是优化器等工作职责</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>执行器的作用就是负责调用底层存储引擎实现的抽象接口，按照优化器输出的执行计划进行执行。执行器才是真正负责执行SQL操作的组件</p><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>存储引擎的作用就是当初MySQL实现的时候留下的可扩展的点，不同的存储引擎的实现可以有着不同的应用场景。MySQL为存储引擎定一个统一的抽象接口，只要不同的存储引擎实现该抽象接口就能被上层的执行器比如OLTP的场景下需要数据库事务的支持，那么InnoDB就是好的选择。而在需要大量读请求而写请求少，并且不需要事物的情况下MyISAM是一个好的选择</p><p>一条SQL的执行就是上面的组件从上到下的执行顺序，下面就用MySQL默认的InnoDB引擎进行展开看看InnoDB的执行原理</p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo-log"></a>redo-log</h4><p>InnoDB有一个重要的模块: <code>redo-log</code>，它是InnoDB支持事物的重要模块。redo-log是物理日志，它记录了哪一个数据页上做了什么修改。可以说如果没有redo-log，InnoDB就不具有crash-safe的能力</p><p>redo-log是由一组分别为4个固定大小文件组成。可以通过MySQL的参数来指定文件的大小。作为日志文件，redo-log是顺序写的，所以写对磁盘来说是非常高效的。数据的结构可以看成是下面的图</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img2020.cnblogs.com/blog/1513538/202009/1513538-20200910161307325-660783359.png" alt=""></p><p>Check-point是当前的数据擦除指针，标识了当前redo-log的擦除文件位置。write-point是写指针，标识了当前的数据写文件位置。InnoDB要保证的是write-point不能超过check-point。check-point要一直保持在write-point之前的一段距离。</p><h4 id="bin-log"><a href="#bin-log" class="headerlink" title="bin-log"></a>bin-log</h4><p>bin-log是MySQL的server层实现的逻辑日志，相当于记录的SQL语句的操作逻辑。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>InnoDB是如何实现crash-safe的呢？一个需要知道的理论就是<code>两阶段提交</code></p><p>两阶段提交用简单点的话讲就是：</p><ol><li>先读取数据，并更新然后将新行数据保存在内存中</li><li>将物理更新记录写入redo-log，并标记这条记录为prepare状态（第一步）</li><li>InnoDB将操作提交到执行器，执行器再将逻辑更新记录写入bin-log，同时调用引擎的写入和更新接口将磁盘文件更新</li><li>上一步操作完成后再提交事物，将redo-log中对应的记录状态改为commit状态（第二步）</li><li>返回更新结果</li></ol><h4 id="崩溃后的数据恢复阶段"><a href="#崩溃后的数据恢复阶段" class="headerlink" title="崩溃后的数据恢复阶段"></a>崩溃后的数据恢复阶段</h4><p>如果在更新或写入数据的过程中，机器出现崩溃。那么在机器在重启后，MySQL会首先去验证redolog的完整性，如果redolog中没有prepare状态的记录，则记录是完整的，就日记提交。如果redolog中存在prepare记录，那么就去验证这条redolog对应的binlog记录，如果这条binlog是完整的，那么完整提交redolog，否则执行回滚逻辑</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL的crash-safe的原理&quot;&gt;&lt;a href=&quot;#MySQL的crash-safe的原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL的crash-safe的原理&quot;&gt;&lt;/a&gt;MySQL的crash-safe的原理&lt;/h1&gt;&lt;h3 i
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.mufeng.tech/public/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://blog.mufeng.tech/public/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于ZooKeeper的分布式锁</title>
    <link href="https://blog.mufeng.tech/public/2020/09/09/%E5%9F%BA%E4%BA%8EZooKeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://blog.mufeng.tech/public/2020/09/09/%E5%9F%BA%E4%BA%8EZooKeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-09-09T06:59:15.000Z</published>
    <updated>2020-09-09T10:00:48.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于ZooKeeper的分布式锁"><a href="#基于ZooKeeper的分布式锁" class="headerlink" title="基于ZooKeeper的分布式锁"></a>基于ZooKeeper的分布式锁</h1><p>这里介绍一下org.apache.curato的所有组件</p><table><thead><tr><th>组件</th><th>介绍</th></tr></thead><tbody><tr><td>curator-client</td><td>代替ZK官方提供的ZK客户端组件</td></tr><tr><td>curator-framework</td><td>在Client基础上构建的高级API，更加方便的使用（依赖管理工具会自动引入底层的Client依赖）</td></tr><tr><td>curator-recipes</td><td>Zookeeper 所有的典型应用场景的实现（除了两阶段提交外）该组件依赖 Client 和 Framework<br/>包括监听、各种分布式锁（可重入锁、排他锁、共享锁、信号锁等）、缓存、队列、选举、<br/>分布式 atomic（分布式计数器）、分布式Barrier 等等。</td></tr><tr><td>curator-examples</td><td>各种高级的使用例子</td></tr><tr><td>curator-x-discovery</td><td>在framework基础上的一个服务发现的实现</td></tr><tr><td>curator-x-discovery-server</td><td>RESTful风格的服务发现服务器</td></tr></tbody></table><p>这里我们引入<code>curator-recipes</code>包含了Client和Framework组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.curator/curator-recipes --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="可重入锁（InterProcessMutex）"><a href="#可重入锁（InterProcessMutex）" class="headerlink" title="可重入锁（InterProcessMutex）"></a>可重入锁（InterProcessMutex）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reentrantLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String lockName = <span class="string">"/lock/reentrantLock"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"测试ZK可重入锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">final</span> InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(zkClient, lockName);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.acquire(<span class="number">100</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"获得锁 Thread- "</span> + finalI);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line"><span class="comment">//        Revoker.attemptRevoke(zkClient, lockName);</span></span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">测试ZK可重入锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">获得锁 Thread- 5</span></span><br><span class="line"><span class="comment">获得锁 Thread- 3</span></span><br><span class="line"><span class="comment">获得锁 Thread- 9</span></span><br><span class="line"><span class="comment">获得锁 Thread- 1</span></span><br><span class="line"><span class="comment">获得锁 Thread- 8</span></span><br><span class="line"><span class="comment">获得锁 Thread- 7</span></span><br><span class="line"><span class="comment">获得锁 Thread- 6</span></span><br><span class="line"><span class="comment">获得锁 Thread- 4</span></span><br><span class="line"><span class="comment">获得锁 Thread- 2</span></span><br><span class="line"><span class="comment">获得锁 Thread- 10</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="可重入读写锁（InterProcessReadWriteLock）"><a href="#可重入读写锁（InterProcessReadWriteLock）" class="headerlink" title="可重入读写锁（InterProcessReadWriteLock）"></a>可重入读写锁（InterProcessReadWriteLock）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWriteLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String lockName = <span class="string">"/lock/readWriteLock"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"ZK读写锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">final</span> InterProcessReadWriteLock lock = <span class="keyword">new</span> InterProcessReadWriteLock(zkClient, lockName);</span><br><span class="line">        AtomicInteger radData = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isRead = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">if</span> (isRead) &#123;</span><br><span class="line">                executorService.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lock.readLock().acquire(<span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"获得Read锁 Thread-"</span> + finalI);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                            System.out.println(<span class="string">"Thread-"</span> + finalI + <span class="string">" 读取到数据: "</span> + radData.getOpaque());</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有获取到读锁 Thread-"</span> + finalI);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.readLock().release();</span><br><span class="line">                            System.out.println(<span class="string">"释放写锁 Thread- "</span> + finalI);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                executorService.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lock.writeLock().acquire(<span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"获得Write锁 Thread-"</span> + finalI);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> value = radData.addAndGet(<span class="number">1</span>);</span><br><span class="line">                            System.out.println(<span class="string">"Thread- "</span>+ finalI +<span class="string">" 写成功："</span> + value);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有获取到写锁 Thread-"</span> + finalI);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.writeLock().release();</span><br><span class="line">                            System.out.println(<span class="string">"释放写锁 Thread- "</span> + finalI);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            isRead = !isRead;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">ZK读写锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">获得Write锁 Thread-2</span></span><br><span class="line"><span class="comment">Thread- 2 写成功：1</span></span><br><span class="line"><span class="comment">获得Write锁 Thread-6</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 2</span></span><br><span class="line"><span class="comment">Thread- 6 写成功：2</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 6</span></span><br><span class="line"><span class="comment">获得Write锁 Thread-4</span></span><br><span class="line"><span class="comment">Thread- 4 写成功：3</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 4</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-1</span></span><br><span class="line"><span class="comment">Thread-1 读取到数据: 3</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 1</span></span><br><span class="line"><span class="comment">获得Write锁 Thread-10</span></span><br><span class="line"><span class="comment">Thread- 10 写成功：4</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 10</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-7</span></span><br><span class="line"><span class="comment">Thread-7 读取到数据: 4</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 7</span></span><br><span class="line"><span class="comment">获得Write锁 Thread-8</span></span><br><span class="line"><span class="comment">Thread- 8 写成功：5</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 8</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-5</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-3</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-9</span></span><br><span class="line"><span class="comment">Thread-5 读取到数据: 5</span></span><br><span class="line"><span class="comment">Thread-9 读取到数据: 5</span></span><br><span class="line"><span class="comment">Thread-3 读取到数据: 5</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 5</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 9</span></span><br><span class="line"><span class="comment">释放写锁 Thread- 3</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="信号量（InterProcessSemaphoreV2）"><a href="#信号量（InterProcessSemaphoreV2）" class="headerlink" title="信号量（InterProcessSemaphoreV2）"></a>信号量（InterProcessSemaphoreV2）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">semaphoreLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(<span class="string">"测试ZK信号量锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">final</span> InterProcessSemaphoreV2 semaphore = <span class="keyword">new</span> InterProcessSemaphoreV2(zkClient, <span class="string">"/lock/semaphore"</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                Lease lease = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lease = semaphore.acquire(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">                    System.out.println(<span class="string">"取得锁 Thread-"</span> + finalI);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lease != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        semaphore.returnLease(lease);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"释放锁 Thread- "</span> + finalI);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 信号量</span></span><br><span class="line"><span class="comment">测试ZK信号量锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">取得锁 Thread-4</span></span><br><span class="line"><span class="comment">取得锁 Thread-9</span></span><br><span class="line"><span class="comment">取得锁 Thread-7</span></span><br><span class="line"><span class="comment">释放锁 Thread- 4</span></span><br><span class="line"><span class="comment">取得锁 Thread-6</span></span><br><span class="line"><span class="comment">释放锁 Thread- 9</span></span><br><span class="line"><span class="comment">取得锁 Thread-8</span></span><br><span class="line"><span class="comment">释放锁 Thread- 7</span></span><br><span class="line"><span class="comment">取得锁 Thread-10</span></span><br><span class="line"><span class="comment">释放锁 Thread- 6</span></span><br><span class="line"><span class="comment">取得锁 Thread-5</span></span><br><span class="line"><span class="comment">释放锁 Thread- 8</span></span><br><span class="line"><span class="comment">取得锁 Thread-3</span></span><br><span class="line"><span class="comment">释放锁 Thread- 10</span></span><br><span class="line"><span class="comment">取得锁 Thread-1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 5</span></span><br><span class="line"><span class="comment">取得锁 Thread-2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 3</span></span><br><span class="line"><span class="comment">释放锁 Thread- 1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 2</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="栅栏（DistributedBarrier）"><a href="#栅栏（DistributedBarrier）" class="headerlink" title="栅栏（DistributedBarrier）"></a>栅栏（DistributedBarrier）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">barrierLock</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">  <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">  System.out.println(<span class="string">"ZK栅栏同步锁"</span>);</span><br><span class="line">  System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">  <span class="keyword">final</span> DistributedBarrier lock = <span class="keyword">new</span> DistributedBarrier(zkClient, <span class="string">"/lock/barrier"</span>);</span><br><span class="line">  lock.setBarrier();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> finalI = i;</span><br><span class="line">    executorService.submit(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"等待中 Thread-"</span> + finalI);</span><br><span class="line">        lock.waitOnBarrier();</span><br><span class="line">        System.out.println(<span class="string">"启动 Thread-"</span> + finalI);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">  lock.removeBarrier();</span><br><span class="line">  countDownLatch.await();</span><br><span class="line">  System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">ZK栅栏同步锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">等待中 Thread-1</span></span><br><span class="line"><span class="comment">等待中 Thread-5</span></span><br><span class="line"><span class="comment">等待中 Thread-7</span></span><br><span class="line"><span class="comment">等待中 Thread-8</span></span><br><span class="line"><span class="comment">等待中 Thread-9</span></span><br><span class="line"><span class="comment">等待中 Thread-10</span></span><br><span class="line"><span class="comment">等待中 Thread-2</span></span><br><span class="line"><span class="comment">等待中 Thread-6</span></span><br><span class="line"><span class="comment">等待中 Thread-4</span></span><br><span class="line"><span class="comment">等待中 Thread-3</span></span><br><span class="line"><span class="comment">启动 Thread-9</span></span><br><span class="line"><span class="comment">启动 Thread-10</span></span><br><span class="line"><span class="comment">启动 Thread-2</span></span><br><span class="line"><span class="comment">启动 Thread-4</span></span><br><span class="line"><span class="comment">启动 Thread-6</span></span><br><span class="line"><span class="comment">启动 Thread-1</span></span><br><span class="line"><span class="comment">启动 Thread-3</span></span><br><span class="line"><span class="comment">启动 Thread-5</span></span><br><span class="line"><span class="comment">启动 Thread-8</span></span><br><span class="line"><span class="comment">启动 Thread-7</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于ZooKeeper的分布式锁&quot;&gt;&lt;a href=&quot;#基于ZooKeeper的分布式锁&quot; class=&quot;headerlink&quot; title=&quot;基于ZooKeeper的分布式锁&quot;&gt;&lt;/a&gt;基于ZooKeeper的分布式锁&lt;/h1&gt;&lt;p&gt;这里介绍一下org.apac
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://blog.mufeng.tech/public/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://blog.mufeng.tech/public/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于Redis的分布式锁</title>
    <link href="https://blog.mufeng.tech/public/2020/09/05/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://blog.mufeng.tech/public/2020/09/05/%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2020-09-05T11:34:23.000Z</published>
    <updated>2020-09-09T10:00:46.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h1><p>Redis使用<code>redisson</code>来实现分布式锁</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Redisson文档</p><p><a href="https://github.com/redisson/redisson/wiki/1.-%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/1.-%E6%A6%82%E8%BF%B0</a></p><p>redisson配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer()</span><br><span class="line">                .setAddress(<span class="string">"redis://localhost:6379"</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用的分布式锁的种类"><a href="#常用的分布式锁的种类" class="headerlink" title="常用的分布式锁的种类"></a>常用的分布式锁的种类</h2><h3 id="可重入锁（ReentrantLock）"><a href="#可重入锁（ReentrantLock）" class="headerlink" title="可重入锁（ReentrantLock）"></a>可重入锁（ReentrantLock）</h3><p>​    对于同一把锁，同一个申请者或者线程在已经获取到锁的情况下，可以重复申请锁，而不会导致死锁情况发生的一种锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可重入锁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reentrantLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"测试可重入锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">final</span> RLock lock = redissonClient.getLock(<span class="string">"reentrantLock"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.tryLock(<span class="number">100</span>, <span class="number">4</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"获得锁 Thread- "</span> + finalI);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">"释放锁 Thread- "</span> + finalI);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出（两两输出）</span></span><br><span class="line"><span class="comment">测试可重入锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">获得锁 Thread- 2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 2</span></span><br><span class="line"><span class="comment">获得锁 Thread- 1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 1</span></span><br><span class="line"><span class="comment">获得锁 Thread- 7</span></span><br><span class="line"><span class="comment">释放锁 Thread- 7</span></span><br><span class="line"><span class="comment">获得锁 Thread- 6</span></span><br><span class="line"><span class="comment">释放锁 Thread- 6</span></span><br><span class="line"><span class="comment">获得锁 Thread- 10</span></span><br><span class="line"><span class="comment">释放锁 Thread- 10</span></span><br><span class="line"><span class="comment">获得锁 Thread- 4</span></span><br><span class="line"><span class="comment">释放锁 Thread- 4</span></span><br><span class="line"><span class="comment">获得锁 Thread- 8</span></span><br><span class="line"><span class="comment">释放锁 Thread- 8</span></span><br><span class="line"><span class="comment">获得锁 Thread- 9</span></span><br><span class="line"><span class="comment">释放锁 Thread- 9</span></span><br><span class="line"><span class="comment">获得锁 Thread- 5</span></span><br><span class="line"><span class="comment">释放锁 Thread- 5</span></span><br><span class="line"><span class="comment">获得锁 Thread- 3</span></span><br><span class="line"><span class="comment">释放锁 Thread- 3</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img2020.cnblogs.com/blog/1513538/202009/1513538-20200905193016575-1595991545.gif" alt="可重入锁"></p><h3 id="公平锁（fairLock）"><a href="#公平锁（fairLock）" class="headerlink" title="公平锁（fairLock）"></a>公平锁（fairLock）</h3><p>按申请前后的顺序获取到锁，先去申请的线程先获取到锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fairLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"测试公平锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">final</span> RLock lock = redissonClient.getFairLock(<span class="string">"fairLock"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lock.tryLock(<span class="number">100</span>, <span class="number">4</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"获得锁 Thread- "</span> + finalI);</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(<span class="string">"释放锁 Thread- "</span> + finalI);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出（两两输出）</span></span><br><span class="line"><span class="comment">测试公平锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">获得锁 Thread- 4</span></span><br><span class="line"><span class="comment">释放锁 Thread- 4</span></span><br><span class="line"><span class="comment">获得锁 Thread- 2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 2</span></span><br><span class="line"><span class="comment">获得锁 Thread- 8</span></span><br><span class="line"><span class="comment">释放锁 Thread- 8</span></span><br><span class="line"><span class="comment">获得锁 Thread- 1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 1</span></span><br><span class="line"><span class="comment">获得锁 Thread- 7</span></span><br><span class="line"><span class="comment">释放锁 Thread- 7</span></span><br><span class="line"><span class="comment">获得锁 Thread- 10</span></span><br><span class="line"><span class="comment">释放锁 Thread- 10</span></span><br><span class="line"><span class="comment">获得锁 Thread- 6</span></span><br><span class="line"><span class="comment">释放锁 Thread- 6</span></span><br><span class="line"><span class="comment">获得锁 Thread- 3</span></span><br><span class="line"><span class="comment">释放锁 Thread- 3</span></span><br><span class="line"><span class="comment">获得锁 Thread- 9</span></span><br><span class="line"><span class="comment">释放锁 Thread- 9</span></span><br><span class="line"><span class="comment">获得锁 Thread- 5</span></span><br><span class="line"><span class="comment">释放锁 Thread- 5</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img2020.cnblogs.com/blog/1513538/202009/1513538-20200905193043459-816471385.gif" alt="公平锁"></p><h3 id="读写锁（RedWriteLock）"><a href="#读写锁（RedWriteLock）" class="headerlink" title="读写锁（RedWriteLock）"></a>读写锁（RedWriteLock）</h3><p>​    针对读操作不会引起资源争抢的情况，做的优化锁。它允许同时拥有多把读书和只有一把写锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readWriteLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(<span class="string">"读写锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">final</span> RReadWriteLock lock = redissonClient.getReadWriteLock(<span class="string">"readWriteLock"</span>);</span><br><span class="line"></span><br><span class="line">        AtomicInteger radData = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isRead = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">if</span> (isRead) &#123;</span><br><span class="line">                executorService.submit(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (lock.readLock().tryLock(<span class="number">100</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"获得Read锁 Thread-"</span> + finalI);</span><br><span class="line">                                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                                System.out.println(<span class="string">"读取到数据: "</span> + radData.getOpaque());</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"没有获取到读锁 Thread-"</span> + finalI);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            lock.readLock().unlock();</span><br><span class="line">                            countDownLatch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                executorService.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lock.writeLock().tryLock(<span class="number">100</span>, <span class="number">30</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"获得Writer锁 Thread-"</span> + finalI);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">int</span> value = radData.addAndGet(<span class="number">1</span>);</span><br><span class="line">                            System.out.println(<span class="string">"写成功："</span> + value);</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"没有获取到写锁 Thread-"</span> + finalI);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.writeLock().unlock();</span><br><span class="line">                        System.out.println(<span class="string">"释放锁 Thread- "</span> + finalI);</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            isRead = !isRead;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">读写锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">获得Writer锁 Thread-10</span></span><br><span class="line"><span class="comment">写成功：1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 10</span></span><br><span class="line"><span class="comment">获得Writer锁 Thread-6</span></span><br><span class="line"><span class="comment">写成功：2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 6</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-3</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-5</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-7</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-1</span></span><br><span class="line"><span class="comment">获得Read锁 Thread-9</span></span><br><span class="line"><span class="comment">读取到数据: 2</span></span><br><span class="line"><span class="comment">读取到数据: 2</span></span><br><span class="line"><span class="comment">读取到数据: 2</span></span><br><span class="line"><span class="comment">读取到数据: 2</span></span><br><span class="line"><span class="comment">读取到数据: 2</span></span><br><span class="line"><span class="comment">获得Writer锁 Thread-4</span></span><br><span class="line"><span class="comment">写成功：3</span></span><br><span class="line"><span class="comment">释放锁 Thread- 4</span></span><br><span class="line"><span class="comment">获得Writer锁 Thread-2</span></span><br><span class="line"><span class="comment">写成功：4</span></span><br><span class="line"><span class="comment">释放锁 Thread- 2</span></span><br><span class="line"><span class="comment">获得Writer锁 Thread-8</span></span><br><span class="line"><span class="comment">写成功：5</span></span><br><span class="line"><span class="comment">释放锁 Thread- 8</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img2020.cnblogs.com/blog/1513538/202009/1513538-20200905193102664-299319743.gif" alt="读写锁"></p><h3 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h3><p>​    对于同一个资源的并发度做的锁限制，在实例化的时候可以指定许可的数量。每个并发线程要持有一个许可，当许可都被领取空时，后面的线程就会阻塞。常用于做并发度的流控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">semaphoreLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(<span class="string">"测试信号量锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">final</span> RSemaphore semaphore = redissonClient.getSemaphore(<span class="string">"semaphoreLock"</span>);</span><br><span class="line">        semaphore.trySetPermits(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(<span class="string">"取得锁 Thread-"</span> + finalI);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(<span class="string">"释放锁 Thread- "</span> + finalI);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">只有两个并发度，两个线程同时执行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">测试信号量锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">取得锁 Thread-3</span></span><br><span class="line"><span class="comment">取得锁 Thread-1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 3</span></span><br><span class="line"><span class="comment">取得锁 Thread-7</span></span><br><span class="line"><span class="comment">取得锁 Thread-4</span></span><br><span class="line"><span class="comment">释放锁 Thread- 4</span></span><br><span class="line"><span class="comment">释放锁 Thread- 7</span></span><br><span class="line"><span class="comment">取得锁 Thread-10</span></span><br><span class="line"><span class="comment">取得锁 Thread-2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 10</span></span><br><span class="line"><span class="comment">取得锁 Thread-6</span></span><br><span class="line"><span class="comment">取得锁 Thread-5</span></span><br><span class="line"><span class="comment">释放锁 Thread- 5</span></span><br><span class="line"><span class="comment">释放锁 Thread- 6</span></span><br><span class="line"><span class="comment">取得锁 Thread-8</span></span><br><span class="line"><span class="comment">取得锁 Thread-9</span></span><br><span class="line"><span class="comment">释放锁 Thread- 8</span></span><br><span class="line"><span class="comment">释放锁 Thread- 9</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img2020.cnblogs.com/blog/1513538/202009/1513538-20200905193122031-781079239.gif" alt="信号量锁"></p><h3 id="倒计锁（CountDownLatch）"><a href="#倒计锁（CountDownLatch）" class="headerlink" title="倒计锁（CountDownLatch）"></a>倒计锁（CountDownLatch）</h3><p>​    常用于协调多个线程，互相等待的场景。在全部线程执行完成后，结束阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_NUMBER = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDownLatchLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        final CountDownLatch countDownLatch = new CountDownLatch(THREAD_NUMBER);</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(<span class="string">"倒数同步锁"</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================================"</span>);</span><br><span class="line">        <span class="keyword">final</span> RCountDownLatch countDownLatch = redissonClient.getCountDownLatch(<span class="string">"countDownLatchLock"</span>);</span><br><span class="line">        countDownLatch.trySetCount(THREAD_NUMBER);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= THREAD_NUMBER; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"取得锁 Thread-"</span> + finalI);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">"释放锁 Thread- "</span> + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"结束..."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">倒数同步锁</span></span><br><span class="line"><span class="comment">============================================================</span></span><br><span class="line"><span class="comment">取得锁 Thread-1</span></span><br><span class="line"><span class="comment">取得锁 Thread-7</span></span><br><span class="line"><span class="comment">取得锁 Thread-8</span></span><br><span class="line"><span class="comment">取得锁 Thread-3</span></span><br><span class="line"><span class="comment">取得锁 Thread-6</span></span><br><span class="line"><span class="comment">取得锁 Thread-4</span></span><br><span class="line"><span class="comment">取得锁 Thread-5</span></span><br><span class="line"><span class="comment">取得锁 Thread-10</span></span><br><span class="line"><span class="comment">取得锁 Thread-9</span></span><br><span class="line"><span class="comment">取得锁 Thread-2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 4</span></span><br><span class="line"><span class="comment">释放锁 Thread- 9</span></span><br><span class="line"><span class="comment">释放锁 Thread- 1</span></span><br><span class="line"><span class="comment">释放锁 Thread- 8</span></span><br><span class="line"><span class="comment">释放锁 Thread- 3</span></span><br><span class="line"><span class="comment">释放锁 Thread- 2</span></span><br><span class="line"><span class="comment">释放锁 Thread- 6</span></span><br><span class="line"><span class="comment">释放锁 Thread- 5</span></span><br><span class="line"><span class="comment">释放锁 Thread- 7</span></span><br><span class="line"><span class="comment">释放锁 Thread- 10</span></span><br><span class="line"><span class="comment">结束...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://img2020.cnblogs.com/blog/1513538/202009/1513538-20200905193143607-151599541.gif" alt="倒数同步锁"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于Redis的分布式锁&quot;&gt;&lt;a href=&quot;#基于Redis的分布式锁&quot; class=&quot;headerlink&quot; title=&quot;基于Redis的分布式锁&quot;&gt;&lt;/a&gt;基于Redis的分布式锁&lt;/h1&gt;&lt;p&gt;Redis使用&lt;code&gt;redisson&lt;/code&gt;来实
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://blog.mufeng.tech/public/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="https://blog.mufeng.tech/public/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Skywalking应用实践(二):服务集成agent探针</title>
    <link href="https://blog.mufeng.tech/public/2020/07/24/Skywalking%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5(%E4%BA%8C):%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90agent%E6%8E%A2%E9%92%88/"/>
    <id>https://blog.mufeng.tech/public/2020/07/24/Skywalking%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5(%E4%BA%8C):%E6%9C%8D%E5%8A%A1%E9%9B%86%E6%88%90agent%E6%8E%A2%E9%92%88/</id>
    <published>2020-07-24T06:40:33.000Z</published>
    <updated>2020-07-24T06:41:42.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Skywalking应用实践-二-服务集成agent探针"><a href="#Skywalking应用实践-二-服务集成agent探针" class="headerlink" title="Skywalking应用实践(二):服务集成agent探针"></a>Skywalking应用实践(二):服务集成agent探针</h1><p>SW支持多种语言的的探针，对于原有的服务代码没有侵入性</p><p>集成原理：</p><p>在在java的启动参数重添加javaagent参数指向skywalking-agent.jar。下面用一个SpringBoot项目为例子构建一个集成SW探针的Docker镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包SpringBoot服务</span></span><br><span class="line"><span class="keyword">FROM</span> maven:<span class="number">3</span>-jdk-<span class="number">11</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /data</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mvn clean package -B -DskipTests</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用jdk11-jre作为运行环境</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> TZ Asia/Shanghai</span><br><span class="line"><span class="comment"># 设置该服务的名字，到时候会是UI界面上的服务标识</span></span><br><span class="line"><span class="keyword">ENV</span> SW_AGENT_NAME example-app-service</span><br><span class="line"><span class="comment"># 设置需要投递数据目的地的oap服务的地址和端口</span></span><br><span class="line"><span class="keyword">ENV</span> SW_AGENT_COLLECTOR_BACKEND_SERVICES you-oap-server-address:<span class="number">11800</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /</span></span><br><span class="line"><span class="comment"># 下载SkyWalking</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> https://mirrors.tuna.tsinghua.edu.cn/apache/skywalking/<span class="variable">$&#123;SKYWALKING_VERSION&#125;</span>/apache-skywalking-apm-<span class="variable">$&#123;SKYWALKING_VERSION&#125;</span>.tar.gz /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压并删除不需要的监控插件（这里删除了Kafka相关的监控）</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -zxvf /apache-skywalking-apm-<span class="variable">$&#123;SKYWALKING_VERSION&#125;</span>.tar.gz &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mv apache-skywalking-apm-bin skywalking &amp;&amp; \</span></span><br><span class="line"><span class="bash">    mv /skywalking/agent/optional-plugins/apm-trace-ignore-plugin* /skywalking/agent/plugins/ &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm /skywalking/agent/plugins/*-kafka-plugin-*.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制构建的应用jar包</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /data</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /data/target/APP.jar .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过javaagent指定SW的探针jar包，并启动APP.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> java -javaagent:/skywalking/agent/skywalking-agent.jar -jar APP.jar</span></span><br></pre></td></tr></table></figure><p>看下agent的配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务的标识</span></span><br><span class="line"><span class="string">agent.service_name=$&#123;SW_AGENT_NAME:Your_ApplicationName&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后端oap服务的地址</span></span><br><span class="line"><span class="string">collector.backend_service=$&#123;SW_AGENT_COLLECTOR_BACKEND_SERVICES:127.0.0.1:11800&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志等级</span></span><br><span class="line"><span class="string">logging.level=$&#123;SW_LOGGING_LEVEL:INFO&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件的大小，超过后将写到新的日志文件中</span></span><br><span class="line"><span class="comment"># Logging max_file_size, default: 300 * 1024 * 1024 = 314572800</span></span><br><span class="line"><span class="string">logging.max_file_size=$&#123;SW_LOGGING_MAX_FILE_SIZE:314572800&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留最老的历史文件数量，-1表示删除立马删除最老的文件</span></span><br><span class="line"><span class="string">logging.max_history_files=$&#123;SW_LOGGING_MAX_HISTORY_FILES:-1&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Skywalking应用实践-二-服务集成agent探针&quot;&gt;&lt;a href=&quot;#Skywalking应用实践-二-服务集成agent探针&quot; class=&quot;headerlink&quot; title=&quot;Skywalking应用实践(二):服务集成agent探针&quot;&gt;&lt;/a&gt;S
      
    
    </summary>
    
    
      <category term="应用总结" scheme="https://blog.mufeng.tech/public/categories/%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="监控" scheme="https://blog.mufeng.tech/public/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="分布式" scheme="https://blog.mufeng.tech/public/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="运维" scheme="https://blog.mufeng.tech/public/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Skywalking应用实践(一): oap服务的搭建</title>
    <link href="https://blog.mufeng.tech/public/2020/07/23/Skywalking%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5(%E4%B8%80):oap%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.mufeng.tech/public/2020/07/23/Skywalking%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5(%E4%B8%80):oap%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2020-07-23T11:34:33.000Z</published>
    <updated>2020-07-24T06:41:00.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Skywalking应用实践-一-oap服务的搭建"><a href="#Skywalking应用实践-一-oap服务的搭建" class="headerlink" title="Skywalking应用实践(一): oap服务的搭建"></a>Skywalking应用实践(一): oap服务的搭建</h1><h2 id="SkyWalking是什么？"><a href="#SkyWalking是什么？" class="headerlink" title="SkyWalking是什么？"></a>SkyWalking是什么？</h2><p>SkyWalking（下面建成SW）是一个APM（应用程序性能监视器）系统。可以监控分布式服务的性能、分布式调用链路追踪、监控结果的可视化。</p><h2 id="SW的组成"><a href="#SW的组成" class="headerlink" title="SW的组成"></a>SW的组成</h2><p>SW由三部分组成：</p><ol><li>skywalking-agent：需要和具体服务集成的探针包，有各种语言的版本</li><li>Skywalking-oap-server：用于收集和存储各个服务推送过来的指标数据，并会给UI系统提供查询接口</li><li>Skywalking-UI：可视化服务系统，以Web的方式提供可视化的数据展示</li></ol><h2 id="以Java项目为例子，SW版本是8-0-1为例子开始搭建整个监控系统"><a href="#以Java项目为例子，SW版本是8-0-1为例子开始搭建整个监控系统" class="headerlink" title="以Java项目为例子，SW版本是8.0.1为例子开始搭建整个监控系统"></a>以Java项目为例子，SW版本是8.0.1为例子开始搭建整个监控系统</h2><p>先下载SkyWalking的预编译包，下载地址是：<a href="https://skywalking.apache.org/zh/downloads/" target="_blank" rel="noopener">https://skywalking.apache.org/zh/downloads/</a></p><p>选择需要的版本进行下载，下载完成后进行解压就能得到目录。实际搭建的服务的时候不会使用这样的方式，这里主要是说明涉及到的几个重要的配置文件可以在下载好的目录里面找到。真实部署的时候，一般都用Docker镜像进行部署。通过搜索DockerHub中的镜像，发现Apache官方给出了SW的的官方镜像的。</p><p>下载的包中几个比较重要的目录和文件</p><ul><li>agent目录：这个目录是探针的目录，里面包含了skywalking-agent.jar这个探针jar包</li><li>agent/config/agent.config文件：这个是探针的配置文件</li><li>config/application.yml文件：skywalking-oap系统的配置文件</li></ul><h3 id="搭建Skywalking-oap-server集群"><a href="#搭建Skywalking-oap-server集群" class="headerlink" title="搭建Skywalking-oap-server集群"></a>搭建Skywalking-oap-server集群</h3><p>数据收集服务的搭建有很多种方式。这里选择用Docker镜像的方式进行部署</p><p>镜像地址：<a href="https://hub.docker.com/r/apache/skywalking-oap-server" target="_blank" rel="noopener">https://hub.docker.com/r/apache/skywalking-oap-server</a></p><p>镜像的具体使用方法，请看镜像介绍页面的介绍。</p><p>先看配置文件：config/application.yml。这个是skywalking-oap-server的配置文件。相关的启动配置都在这里面</p><p>每个分类下面的selecor标识用于表示服务启用时选择读取哪一块的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="string">$&#123;SW_CLUSTER:standalone&#125;</span></span><br><span class="line">  <span class="attr">standalone:</span></span><br><span class="line">  <span class="comment"># Please check your ZooKeeper is 3.5+, However, it is also compatible with ZooKeeper 3.4.x. Replace the ZooKeeper 3.5+</span></span><br><span class="line">  <span class="comment"># library the oap-libs folder with your ZooKeeper 3.4.x library.</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">nameSpace:</span> <span class="string">$&#123;SW_NAMESPACE:""&#125;</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="string">$&#123;SW_CLUSTER_ZK_HOST_PORT:localhost:2181&#125;</span></span><br><span class="line">    <span class="comment"># Retry Policy</span></span><br><span class="line">    <span class="attr">baseSleepTimeMs:</span> <span class="string">$&#123;SW_CLUSTER_ZK_SLEEP_TIME:1000&#125;</span> <span class="comment"># initial amount of time to wait between retries</span></span><br><span class="line">    <span class="attr">maxRetries:</span> <span class="string">$&#123;SW_CLUSTER_ZK_MAX_RETRIES:3&#125;</span> <span class="comment"># max number of times to retry</span></span><br><span class="line">    <span class="comment"># Enable ACL</span></span><br><span class="line">    <span class="attr">enableACL:</span> <span class="string">$&#123;SW_ZK_ENABLE_ACL:false&#125;</span> <span class="comment"># disable ACL in default</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">$&#123;SW_ZK_SCHEMA:digest&#125;</span> <span class="comment"># only support digest schema</span></span><br><span class="line">    <span class="attr">expression:</span> <span class="string">$&#123;SW_ZK_EXPRESSION:skywalking:skywalking&#125;</span></span><br><span class="line">  <span class="attr">kubernetes:</span></span><br><span class="line">    <span class="attr">watchTimeoutSeconds:</span> <span class="string">$&#123;SW_CLUSTER_K8S_WATCH_TIMEOUT:60&#125;</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">$&#123;SW_CLUSTER_K8S_NAMESPACE:default&#125;</span></span><br><span class="line">    <span class="attr">labelSelector:</span> <span class="string">$&#123;SW_CLUSTER_K8S_LABEL:app=collector,release=skywalking&#125;</span></span><br><span class="line">    <span class="attr">uidEnvName:</span> <span class="string">$&#123;SW_CLUSTER_K8S_UID:SKYWALKING_COLLECTOR_UID&#125;</span></span><br><span class="line">  <span class="attr">consul:</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">$&#123;SW_SERVICE_NAME:"SkyWalking_OAP_Cluster"&#125;</span></span><br><span class="line">    <span class="comment"># Consul cluster nodes, example: 10.0.0.1:8500,10.0.0.2:8500,10.0.0.3:8500</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="string">$&#123;SW_CLUSTER_CONSUL_HOST_PORT:localhost:8500&#125;</span></span><br><span class="line">    <span class="attr">aclToken:</span> <span class="string">$&#123;SW_CLUSTER_CONSUL_ACLTOKEN:""&#125;</span></span><br><span class="line">  <span class="attr">etcd:</span></span><br><span class="line">    <span class="attr">serviceName:</span> <span class="string">$&#123;SW_SERVICE_NAME:"SkyWalking_OAP_Cluster"&#125;</span></span><br><span class="line">    <span class="comment"># etcd cluster nodes, example: 10.0.0.1:2379,10.0.0.2:2379,10.0.0.3:2379</span></span><br><span class="line">    <span class="attr">hostPort:</span> <span class="string">$&#123;SW_CLUSTER_ETCD_HOST_PORT:localhost:2379&#125;</span></span><br></pre></td></tr></table></figure><p>通过配置文件我们可以看到，采集服务的搭建支持单例模式和集群模式，生产环境下为了高可用肯定要选择集群模式</p><p>集群模式中可以选择不同的集群协调中间件：</p><ul><li>zookeeper</li><li>kubernetes</li><li>consul</li><li>etcd</li></ul><p>选择自己合适的中间件来搭建集群</p><p>下面是核心的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">core:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="string">$&#123;SW_CORE:default&#125;</span></span><br><span class="line">  <span class="attr">default:</span></span><br><span class="line">    <span class="comment"># Mixed: Receive agent data, Level 1 aggregate, Level 2 aggregate</span></span><br><span class="line">    <span class="comment"># Receiver: Receive agent data, Level 1 aggregate</span></span><br><span class="line">    <span class="comment"># Aggregator: Level 2 aggregate</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">$&#123;SW_CORE_ROLE:Mixed&#125;</span> <span class="comment"># Mixed/Receiver/Aggregator</span></span><br><span class="line">    <span class="attr">restHost:</span> <span class="string">$&#123;SW_CORE_REST_HOST:0.0.0.0&#125;</span></span><br><span class="line">    <span class="attr">restPort:</span> <span class="string">$&#123;SW_CORE_REST_PORT:12800&#125;</span></span><br><span class="line">    <span class="attr">restContextPath:</span> <span class="string">$&#123;SW_CORE_REST_CONTEXT_PATH:/&#125;</span></span><br><span class="line">    <span class="attr">gRPCHost:</span> <span class="string">$&#123;SW_CORE_GRPC_HOST:0.0.0.0&#125;</span></span><br><span class="line">    <span class="attr">gRPCPort:</span> <span class="string">$&#123;SW_CORE_GRPC_PORT:11800&#125;</span></span><br><span class="line">    <span class="attr">gRPCSslEnabled:</span> <span class="string">$&#123;SW_CORE_GRPC_SSL_ENABLED:false&#125;</span></span><br><span class="line">    <span class="attr">gRPCSslKeyPath:</span> <span class="string">$&#123;SW_CORE_GRPC_SSL_KEY_PATH:""&#125;</span></span><br><span class="line">    <span class="attr">gRPCSslCertChainPath:</span> <span class="string">$&#123;SW_CORE_GRPC_SSL_CERT_CHAIN_PATH:""&#125;</span></span><br><span class="line">    <span class="attr">gRPCSslTrustedCAPath:</span> <span class="string">$&#123;SW_CORE_GRPC_SSL_TRUSTED_CA_PATH:""&#125;</span></span><br><span class="line">    <span class="attr">downsampling:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Hour</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Day</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Month</span></span><br><span class="line">    <span class="attr">enableDataKeeperExecutor:</span> <span class="string">$&#123;SW_CORE_ENABLE_DATA_KEEPER_EXECUTOR:true&#125;</span> </span><br><span class="line">    <span class="attr">dataKeeperExecutePeriod:</span> <span class="string">$&#123;SW_CORE_DATA_KEEPER_EXECUTE_PERIOD:5&#125;</span> </span><br><span class="line">    <span class="attr">recordDataTTL:</span> <span class="string">$&#123;SW_CORE_RECORD_DATA_TTL:3&#125;</span> <span class="comment"># Unit is day</span></span><br><span class="line">    <span class="attr">metricsDataTTL:</span> <span class="string">$&#123;SW_CORE_RECORD_DATA_TTL:7&#125;</span> <span class="comment"># Unit is day</span></span><br></pre></td></tr></table></figure><p>SW_CORE_REST_PORT：该环境变量可以指定暴力给UI服务查询的端口</p><p>SW_CORE_GRPC_PORT：该环境变量可以指定agent服务上传数据的端口</p><p>SW_CORE_RECORD_DATA_TTL：该环境变量可以指定数据的存放时间</p><p>下面部分是收集服务的数据存储类型的选择</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="string">$&#123;SW_STORAGE:elasticsearch&#125;</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">nameSpace:</span> <span class="string">$&#123;SW_NAMESPACE:""&#125;</span></span><br><span class="line">    <span class="attr">clusterNodes:</span> <span class="string">$&#123;SW_STORAGE_ES_CLUSTER_NODES:localhost:9200&#125;</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">$&#123;SW_STORAGE_ES_HTTP_PROTOCOL:"http"&#125;</span></span><br><span class="line">    <span class="attr">trustStorePath:</span> <span class="string">$&#123;SW_STORAGE_ES_SSL_JKS_PATH:""&#125;</span></span><br><span class="line">    <span class="attr">trustStorePass:</span> <span class="string">$&#123;SW_STORAGE_ES_SSL_JKS_PASS:""&#125;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;SW_ES_USER:""&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;SW_ES_PASSWORD:""&#125;</span></span><br><span class="line">    <span class="attr">secretsManagementFile:</span> <span class="string">$&#123;SW_ES_SECRETS_MANAGEMENT_FILE:""&#125;</span> <span class="comment"># Secrets management file in the properties format includes the username, password, which are managed by 3rd party tool.</span></span><br><span class="line">    <span class="attr">dayStep:</span> <span class="string">$&#123;SW_STORAGE_DAY_STEP:1&#125;</span> <span class="comment"># Represent the number of days in the one minute/hour/day index.</span></span><br><span class="line">    <span class="attr">indexShardsNumber:</span> <span class="string">$&#123;SW_STORAGE_ES_INDEX_SHARDS_NUMBER:1&#125;</span> <span class="comment"># The index shards number is for store metrics data rather than basic segment record</span></span><br><span class="line">    <span class="attr">superDatasetIndexShardsFactor:</span> <span class="string">$&#123;SW_STORAGE_ES_SUPER_DATASET_INDEX_SHARDS_FACTOR:5&#125;</span> <span class="comment"># Super data set has been defined in the codes, such as trace segments. This factor provides more shards for the super data set, shards number = indexShardsNumber * superDatasetIndexShardsFactor. Also, this factor effects Zipkin and Jaeger traces.</span></span><br><span class="line">    <span class="attr">indexReplicasNumber:</span> <span class="string">$&#123;SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:0&#125;</span></span><br><span class="line">    <span class="comment"># Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html</span></span><br><span class="line">    <span class="attr">bulkActions:</span> <span class="string">$&#123;SW_STORAGE_ES_BULK_ACTIONS:1000&#125;</span> <span class="comment"># Execute the bulk every 1000 requests</span></span><br><span class="line">    <span class="attr">flushInterval:</span> <span class="string">$&#123;SW_STORAGE_ES_FLUSH_INTERVAL:10&#125;</span> <span class="comment"># flush the bulk every 10 seconds whatever the number of requests</span></span><br><span class="line">    <span class="attr">concurrentRequests:</span> <span class="string">$&#123;SW_STORAGE_ES_CONCURRENT_REQUESTS:2&#125;</span> <span class="comment"># the number of concurrent requests</span></span><br><span class="line">    <span class="attr">resultWindowMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_MAX_WINDOW_SIZE:10000&#125;</span></span><br><span class="line">    <span class="attr">metadataQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_MAX_SIZE:5000&#125;</span></span><br><span class="line">    <span class="attr">segmentQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200&#125;</span></span><br><span class="line">    <span class="attr">profileTaskQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_PROFILE_TASK_SIZE:200&#125;</span></span><br><span class="line">    <span class="attr">advanced:</span> <span class="string">$&#123;SW_STORAGE_ES_ADVANCED:""&#125;</span></span><br><span class="line">  <span class="attr">elasticsearch7:</span></span><br><span class="line">    <span class="attr">nameSpace:</span> <span class="string">$&#123;SW_NAMESPACE:""&#125;</span></span><br><span class="line">    <span class="attr">clusterNodes:</span> <span class="string">$&#123;SW_STORAGE_ES_CLUSTER_NODES:localhost:9200&#125;</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">$&#123;SW_STORAGE_ES_HTTP_PROTOCOL:"http"&#125;</span></span><br><span class="line">    <span class="attr">trustStorePath:</span> <span class="string">$&#123;SW_STORAGE_ES_SSL_JKS_PATH:""&#125;</span></span><br><span class="line">    <span class="attr">trustStorePass:</span> <span class="string">$&#123;SW_STORAGE_ES_SSL_JKS_PASS:""&#125;</span></span><br><span class="line">    <span class="attr">dayStep:</span> <span class="string">$&#123;SW_STORAGE_DAY_STEP:1&#125;</span> <span class="comment"># Represent the number of days in the one minute/hour/day index.</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;SW_ES_USER:""&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;SW_ES_PASSWORD:""&#125;</span></span><br><span class="line">    <span class="attr">secretsManagementFile:</span> <span class="string">$&#123;SW_ES_SECRETS_MANAGEMENT_FILE:""&#125;</span> <span class="comment"># Secrets management file in the properties format includes the username, password, which are managed by 3rd party tool.</span></span><br><span class="line">    <span class="attr">indexShardsNumber:</span> <span class="string">$&#123;SW_STORAGE_ES_INDEX_SHARDS_NUMBER:1&#125;</span> <span class="comment"># The index shards number is for store metrics data rather than basic segment record</span></span><br><span class="line">    <span class="attr">superDatasetIndexShardsFactor:</span> <span class="string">$&#123;SW_STORAGE_ES_SUPER_DATASET_INDEX_SHARDS_FACTOR:5&#125;</span> <span class="comment"># Super data set has been defined in the codes, such as trace segments. This factor provides more shards for the super data set, shards number = indexShardsNumber * superDatasetIndexShardsFactor. Also, this factor effects Zipkin and Jaeger traces.</span></span><br><span class="line">    <span class="attr">indexReplicasNumber:</span> <span class="string">$&#123;SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:0&#125;</span></span><br><span class="line">    <span class="comment"># Batch process setting, refer to https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.5/java-docs-bulk-processor.html</span></span><br><span class="line">    <span class="attr">bulkActions:</span> <span class="string">$&#123;SW_STORAGE_ES_BULK_ACTIONS:1000&#125;</span> <span class="comment"># Execute the bulk every 1000 requests</span></span><br><span class="line">    <span class="attr">flushInterval:</span> <span class="string">$&#123;SW_STORAGE_ES_FLUSH_INTERVAL:10&#125;</span> <span class="comment"># flush the bulk every 10 seconds whatever the number of requests</span></span><br><span class="line">    <span class="attr">concurrentRequests:</span> <span class="string">$&#123;SW_STORAGE_ES_CONCURRENT_REQUESTS:2&#125;</span> <span class="comment"># the number of concurrent requests</span></span><br><span class="line">    <span class="attr">resultWindowMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_MAX_WINDOW_SIZE:10000&#125;</span></span><br><span class="line">    <span class="attr">metadataQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_MAX_SIZE:5000&#125;</span></span><br><span class="line">    <span class="attr">segmentQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200&#125;</span></span><br><span class="line">    <span class="attr">profileTaskQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_ES_QUERY_PROFILE_TASK_SIZE:200&#125;</span></span><br><span class="line">    <span class="attr">advanced:</span> <span class="string">$&#123;SW_STORAGE_ES_ADVANCED:""&#125;</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">$&#123;SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource&#125;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">$&#123;SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db&#125;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;SW_STORAGE_H2_USER:sa&#125;</span></span><br><span class="line">    <span class="attr">metadataQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_H2_QUERY_MAX_SIZE:5000&#125;</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">jdbcUrl:</span> <span class="string">$&#123;SW_JDBC_URL:"jdbc:mysql://localhost:3306/swtest"&#125;</span></span><br><span class="line">      <span class="attr">dataSource.user:</span> <span class="string">$&#123;SW_DATA_SOURCE_USER:root&#125;</span></span><br><span class="line">      <span class="attr">dataSource.password:</span> <span class="string">$&#123;SW_DATA_SOURCE_PASSWORD:root@1234&#125;</span></span><br><span class="line">      <span class="attr">dataSource.cachePrepStmts:</span> <span class="string">$&#123;SW_DATA_SOURCE_CACHE_PREP_STMTS:true&#125;</span></span><br><span class="line">      <span class="attr">dataSource.prepStmtCacheSize:</span> <span class="string">$&#123;SW_DATA_SOURCE_PREP_STMT_CACHE_SQL_SIZE:250&#125;</span></span><br><span class="line">      <span class="attr">dataSource.prepStmtCacheSqlLimit:</span> <span class="string">$&#123;SW_DATA_SOURCE_PREP_STMT_CACHE_SQL_LIMIT:2048&#125;</span></span><br><span class="line">      <span class="attr">dataSource.useServerPrepStmts:</span> <span class="string">$&#123;SW_DATA_SOURCE_USE_SERVER_PREP_STMTS:true&#125;</span></span><br><span class="line">    <span class="attr">metadataQueryMaxSize:</span> <span class="string">$&#123;SW_STORAGE_MYSQL_QUERY_MAX_SIZE:5000&#125;</span></span><br><span class="line">  <span class="attr">influxdb:</span></span><br><span class="line">    <span class="comment"># InfluxDB configuration</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">$&#123;SW_STORAGE_INFLUXDB_URL:http://localhost:8086&#125;</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">$&#123;SW_STORAGE_INFLUXDB_USER:root&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;SW_STORAGE_INFLUXDB_PASSWORD:&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;SW_STORAGE_INFLUXDB_DATABASE:skywalking&#125;</span></span><br><span class="line">    <span class="attr">actions:</span> <span class="string">$&#123;SW_STORAGE_INFLUXDB_ACTIONS:1000&#125;</span> <span class="comment"># the number of actions to collect</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="string">$&#123;SW_STORAGE_INFLUXDB_DURATION:1000&#125;</span> <span class="comment"># the time to wait at most (milliseconds)</span></span><br><span class="line">    <span class="attr">fetchTaskLogMaxSize:</span> <span class="string">$&#123;SW_STORAGE_INFLUXDB_FETCH_TASK_LOG_MAX_SIZE:5000&#125;</span> <span class="comment"># the max number of fetch task log in a request</span></span><br></pre></td></tr></table></figure><p>可以看到服务支持的后端输出存储有：</p><ul><li>elasticsearch</li><li>h2</li><li>mysql</li><li>influxdb</li></ul><p>官方推荐使用elasticsearch作为后端存储</p><ul><li>SW_STORAGE_ES_CLUSTER_NODES：指向elasticsearch服务的地址</li><li>SW_ES_USER：elasticsearch的用户名</li><li>SW_ES_PASSWORD：elasticsearch的密码</li></ul><p>启动Docker镜像</p><p>可以根据配置文件的中的配置，可以传入环境变量进行配置的覆盖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --name oap --restart always -d \</span></span><br><span class="line">-e SW_STORAGE=elasticsearch \</span><br><span class="line">-e SW_STORAGE_ES_CLUSTER_NODES=elasticsearch:9200 \</span><br><span class="line">apache/skywalking-oap-server</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>项目地址：<a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">https://github.com/apache/skywalking</a></p></li><li><p>文档：<a href="https://github.com/apache/skywalking/tree/master/docs" target="_blank" rel="noopener">https://github.com/apache/skywalking/tree/master/docs</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Skywalking应用实践-一-oap服务的搭建&quot;&gt;&lt;a href=&quot;#Skywalking应用实践-一-oap服务的搭建&quot; class=&quot;headerlink&quot; title=&quot;Skywalking应用实践(一): oap服务的搭建&quot;&gt;&lt;/a&gt;Skywalkin
      
    
    </summary>
    
    
      <category term="应用总结" scheme="https://blog.mufeng.tech/public/categories/%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="监控" scheme="https://blog.mufeng.tech/public/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="分布式" scheme="https://blog.mufeng.tech/public/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="运维" scheme="https://blog.mufeng.tech/public/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码解析</title>
    <link href="https://blog.mufeng.tech/public/2020/07/18/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.mufeng.tech/public/2020/07/18/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-07-18T06:16:08.000Z</published>
    <updated>2020-07-18T06:18:07.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS源码解析"><a href="#AQS源码解析" class="headerlink" title="AQS源码解析"></a>AQS源码解析</h1><h2 id="AQS是什么？"><a href="#AQS是什么？" class="headerlink" title="AQS是什么？"></a>AQS是什么？</h2><p>全称是<code>AbstractQueuedSynchronizer</code>，位于java.util.concurrent.locks包下面。AbstractQueuedSynchronizer是一个抽象类，其常见的派生子类有，ReentrantLock.Sync内部类。</p><h3 id="申请锁入口方法"><a href="#申请锁入口方法" class="headerlink" title="申请锁入口方法"></a>申请锁入口方法</h3><p>acquire方法为AQS中用于申请锁定的入口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先尝试使用去获取锁，如果失败，则尝试加入申请队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试申请失败，并且加入等待线程队列的后线程状态为中断状态的情况</span></span><br><span class="line">  <span class="comment">// addWaiter也是自旋操作</span></span><br><span class="line">  <span class="comment">// acquireQueued方法中拥有自旋操作</span></span><br><span class="line">  <span class="comment">// 所以 addWaiter 和 acquireQueued只要执行完成说明已经获取到了锁</span></span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    <span class="comment">// 进行自我中断</span></span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法是是AQS中用于尝试申请锁的方法，这里用到的模板方法，如果子类中没有重写改方法，那么直接调用会出错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试锁定成功会返回true，失败返回返回false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addWaiter()方法会生成一个等待队列的节点，并且会自旋的去加入等待队列的尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  Node node = <span class="keyword">new</span> Node(mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自旋加入</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 获取当前的队尾元素</span></span><br><span class="line">    Node oldTail = tail;</span><br><span class="line">    <span class="comment">// 如果存在队尾元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前节点添加到队尾</span></span><br><span class="line">      node.setPrevRelaxed(oldTail);</span><br><span class="line">      <span class="comment">// 用CAS算法设置当前AQS的队尾元素为当前节点</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">        <span class="comment">// 当前队尾元素的的后置节点设置为当前节点，进行两个节点的双向绑定</span></span><br><span class="line">        oldTail.next = node;</span><br><span class="line">        <span class="comment">// 返回当前的节点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不存在队尾元素，就执行队列初始化操作</span></span><br><span class="line">      initializeSyncQueue();</span><br><span class="line">      <span class="comment">// 执行完成后，但下一个for循环进入后，初始化完毕了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initializeSyncQueue()初始化等待队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node h;</span><br><span class="line">  <span class="comment">// 用CAS算法生成一个头节点</span></span><br><span class="line">  <span class="keyword">if</span> (HEAD.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</span><br><span class="line">    <span class="comment">// 生成头节点成功后，将头节点也指定为尾节点</span></span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued()调度申请线程队列的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋处理等待的线程队列</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 取当前队列的前置节点，p</span></span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">      <span class="comment">// 如果p是AQS的头节点，那先去尝试获取AQS的锁如果成功</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        <span class="comment">// 设置当前的节点为头节点</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">// 节点已被使用，将元素指定为null，帮助GC回收内存</span></span><br><span class="line">        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        <span class="comment">// 返回当前线程的是的中断状态</span></span><br><span class="line">        <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不是头节点或者不能成功申请到锁的情况</span></span><br><span class="line">      <span class="comment">// 当前线程是否需要暂停</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node))</span><br><span class="line">        <span class="comment">// 等同于 interrupted = interrupted | parkAndCheckInterrupt()</span></span><br><span class="line">        <span class="comment">// 暂停当前线程，并获取当前线程的中断状态</span></span><br><span class="line">        interrupted |= parkAndCheckInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    cancelAcquire(node);</span><br><span class="line">    <span class="keyword">if</span> (interrupted)</span><br><span class="line">      selfInterrupt();</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shouldParkAfterFailedAcquire()判断当前等待的线程节点是否需要阻塞并停止调度，传入当前节点的前置节点和当前节点作为参数</p><p>waitStatus的种类</p><ul><li>初始化状态：0</li><li>SIGNAL：-1</li><li>CANCELLED: 1</li><li>CONDITION: -2</li><li>PROPAGATE: -3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 前置的节点的等待状态</span></span><br><span class="line">  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">  <span class="comment">// 如果前置节点为SIGNAL状态，说明当前节点为下一个启动节点，可以暂停当前节点线程的调度</span></span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">// 如果大于0，说明前置节点已被取消</span></span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="comment">// 跳过当前的前置节点，往前寻找下一个不是取消状态的节点</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 当前前置节点的前一个节点作为前置节点，并且将其指定为当前节点的前置节点</span></span><br><span class="line">      node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 跳过前置节点后寻找到的非取消节点的后置节点为当前节点</span></span><br><span class="line">    pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="comment">// 如果是初始状态没有设置过waitStatus的情况或者是共享节点用到的需要传播状态时</span></span><br><span class="line">    <span class="comment">// 使用CAS算法将前置节点的状态变为SIGNAL状态</span></span><br><span class="line">    pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parkAndCheckInterrupt() 阻塞当前线程并停止其调度，以节约系统的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 暂停当前线程</span></span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 返回当前线程的中断状态，true表示当前线程已经被中断</span></span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AQS源码解析&quot;&gt;&lt;a href=&quot;#AQS源码解析&quot; class=&quot;headerlink&quot; title=&quot;AQS源码解析&quot;&gt;&lt;/a&gt;AQS源码解析&lt;/h1&gt;&lt;h2 id=&quot;AQS是什么？&quot;&gt;&lt;a href=&quot;#AQS是什么？&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.mufeng.tech/public/categories/Java/"/>
    
      <category term="并发" scheme="https://blog.mufeng.tech/public/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java基础" scheme="https://blog.mufeng.tech/public/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的事务和数据恢复</title>
    <link href="https://blog.mufeng.tech/public/2020/06/23/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    <id>https://blog.mufeng.tech/public/2020/06/23/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/</id>
    <published>2020-06-23T08:12:18.000Z</published>
    <updated>2020-06-24T01:17:09.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的事务和数据恢复"><a href="#MySQL的事务和数据恢复" class="headerlink" title="MySQL的事务和数据恢复"></a>MySQL的事务和数据恢复</h1><h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><ul><li><strong>脏读</strong>：某一个事务修改了数据，但未提交的情况下，这时另一个事务读取了该行数据。那么读取的这个事务读的数据称为脏数据。这种情况称为脏读</li><li><strong>不可重复读</strong>：在一个事务内，多次读取同一个数据，这个事务没有结束时，另一个事务修改了该数据，导致上一个事务中，多次读取的数据不一致的问题，因此称为不可重复读</li><li><strong>幻读</strong>：与不可重复读相似。一个事务读取了几行数据，在当前事务未提交的时候，另外一个事务插入了几条新的数据。前一个事务在随后的查询中发现新多了几条数据</li></ul><p>不可重复读与幻读的区别：不可重复读出现在数据更新的事务中，如UPDATE语句中。而幻读出现在数据增删的情况中，如INSERT，DELETE语句中</p><h2 id="MySQL的事务隔离等级"><a href="#MySQL的事务隔离等级" class="headerlink" title="MySQL的事务隔离等级"></a>MySQL的事务隔离等级</h2><ul><li><strong>(READ-UNCOMMITTED)读取未提交</strong>: 允许读取未提交的数据,最低的隔离等级,可能会导致脏读,幻读,不可重复读。</li><li><strong>(READ-COMMITTED)读取已提交</strong>: 允许读取已提交的数据, 避免了脏读, 但会存在不可重复读和幻读。</li><li><strong>(REPEATABLE-READ)可重复读</strong>: MySQL默认的事务隔离等级,保证同一个字段的多次读取结果一致, 除非被本事务修改。避免了脏读，不可重复读，但有在幻读的可能。</li><li><strong>(SERIALIZEABLE)串行化</strong>：最高的隔离等级，所有事务逐个执行，事务之间不存在干扰。</li></ul><h4 id="数据库事务隔离等级的通俗总结的很好"><a href="#数据库事务隔离等级的通俗总结的很好" class="headerlink" title="数据库事务隔离等级的通俗总结的很好"></a>数据库事务隔离等级的通俗总结的很好</h4><ul><li>读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。</li><li>读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。</li><li>可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。</li><li>串行：我的事务尚未提交，别人就别想改数据。<br>这4种隔离级别，并行性能依次降低，安全性依次提高。</li></ul><h4 id="Spring的事务隔离等级"><a href="#Spring的事务隔离等级" class="headerlink" title="Spring的事务隔离等级"></a>Spring的事务隔离等级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line">public enum Isolation &#123;</span><br><span class="line">    DEFAULT(-1),</span><br><span class="line">    READ_UNCOMMITTED(1),</span><br><span class="line">    READ_COMMITTED(2),</span><br><span class="line">    REPEATABLE_READ(4),</span><br><span class="line">    SERIALIZABLE(8);</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    private Isolation(int value) &#123;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int value() &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和MySQL的事务隔离等级相互对应。值多了一个默认枚举类型，<code>DEFAULT</code>表示遵循数据库的事务隔离等级</p><h4 id="Spring的事务传递行为"><a href="#Spring的事务传递行为" class="headerlink" title="Spring的事务传递行为"></a>Spring的事务传递行为</h4><p>什么是事务的传播行为？比如在方法A中开启了事务，在事务B中也开启了事务，在执行期间事务的维护情况，就是事务的传播行为。总共有下面七种</p><ul><li>REQUIRED：指定的方法必须在事务内执行。若当前存在事务，就加入到当前事务中；若当前没有事务，则创建一个新事务。这种传播行为是最常见的选择，也是 Spring 默认的事务传播行为。</li><li>SUPPORTS：指定的方法支持当前事务，但若当前没有事务，也可以以非事务方式执行。</li><li>MANDATORY：指定的方法必须在当前事务内执行，若当前没有事务，则直接抛出异常。</li><li>REQUIRES_NEW：总是新建一个事务，若当前存在事务，就将当前事务挂起，直到新事务执行完毕。</li><li>NOT_SUPPORTED：指定的方法不能在事务环境中执行，若当前存在事务，就将当前事务挂起。</li><li>NEVER：指定的方法不能在事务环境下执行，若当前存在事务，就直接抛出异常。</li><li>NESTED：指定的方法必须在事务内执行。若当前存在事务，则在嵌套事务内执行；若当前没有事务，则创建一个新事务。</li></ul><h4 id="MySQL中如何查看当前数据库系统的事务隔离等级"><a href="#MySQL中如何查看当前数据库系统的事务隔离等级" class="headerlink" title="MySQL中如何查看当前数据库系统的事务隔离等级"></a>MySQL中如何查看当前数据库系统的事务隔离等级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show variables like &#39;transaction_isolation&#39;;</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure><h4 id="事务隔离的实现原理"><a href="#事务隔离的实现原理" class="headerlink" title="事务隔离的实现原理"></a>事务隔离的实现原理</h4><p>在MySQL的中InnoDB引擎下，每一次的更新都会生成一条undo日志，用于回滚操作。那他是如何做到事务之间的数据可见性隔离的呢？这里就涉及到MySQL的多版本并发控制（MVCC）。在启动MySQL事务的时候，每个事务会创建一个当前数据的视图。在可重复读的隔离等级下，不会因为其他的事务被提交而导致当前事务下出现数据不可重复读的问题。</p><p>那这个数据视图是什么呢？这个视图被称为一致性读视图是<strong>读提交</strong>和<strong>可重复读</strong>隔离级别的实现。他没有物理实现，是根据事务执行期间动态计算得到的。</p><p>事务的创建逻辑</p><ol><li>向InnoDB事务系统申请唯一的事务ID，是一个严格递增的ID</li><li>记录当前事务系统中活跃但未提交事务ID列表到当前的事务ID数组中，并严格排序，最小的ID为低水位ID，最大的ID+1为高水位ID</li></ol><p>事务数据可见性的判断逻辑：</p><ol><li>数据版本的事务ID如果小于当前事务的最小水位ID，说明是本事务创建前就提交的，可见</li><li>数据版本的事务ID如果大于最大水位ID，说明是在本事务创建后再创建的事务，肯定不可见</li><li>数据的版本事务ID如果在最小水位和最大水位之间，有两种情况<ol><li>存在事务数组中，说明是由没提交的事务生成的，不可见</li><li>不在事务数组中，说明这个版本是由已提交的事务生成的，可见</li></ol></li></ol><p>那如果当前事务ID已经落后于最新的数据版本，那应该如果找到当前的数据版本的数据呢？那就需要undo log了，通过undo log计算出当前数据行针对当前事务的的数据版本</p><h2 id="InnoDB存储引擎的锁的算法"><a href="#InnoDB存储引擎的锁的算法" class="headerlink" title="InnoDB存储引擎的锁的算法"></a>InnoDB存储引擎的锁的算法</h2><ul><li>Record lock：单个行记录上的锁<ul><li>在查询存在唯一索引的时候用来锁定单条记录</li></ul></li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身<ul><li>设计的目的是解决多个事务将记录插入到同一个范围内，导致幻读问题</li><li>如：查询条件中存在范围条件语句，如：between、&gt; 、&lt;、 &lt;= 、&gt;=等</li></ul></li><li>Next-key lock：record+gap 锁定一个范围，包含记录本身<ul><li>设计的目的是解决幻读问题</li></ul></li></ul><h2 id="MySQL是如何保证机器异常重启后不丢失数据的？"><a href="#MySQL是如何保证机器异常重启后不丢失数据的？" class="headerlink" title="MySQL是如何保证机器异常重启后不丢失数据的？"></a>MySQL是如何保证机器异常重启后不丢失数据的？</h2><p>涉及到MySQL的数据更新机制。binlog（归档日志）和redolog（重做日志）。MySQL默认的InnoDB引擎会将更新数据先存在内存中，同时将记录redolog，该条redolog的状态是perpare，然后将操作提交至执行器。执行器收到任务后，写入binlog，同时调用引擎接口写入或更新数据，成功后将之前的redolog改为commit状态。</p><p>如果在更新或写入数据的过程中，机器出现崩溃。那么在机器在重启后，MySQL会首先去验证redolog的完整性，如果redolog中没有prepare状态的记录，则记录是完整的，就日记提交。如果redolog中存在prepare记录，那么就去验证这条redolog对应的binlog记录，如果这条binlog是完整的，那么完整提交redolog，否则执行回滚逻辑</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《MySQL实战45讲》—极客时间</p><p><a href="https://www.funtl.com/zh/spring-transaction/#spring-事务管理-api" target="_blank" rel="noopener">https://www.funtl.com/zh/spring-transaction/#spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-api</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL的事务和数据恢复&quot;&gt;&lt;a href=&quot;#MySQL的事务和数据恢复&quot; class=&quot;headerlink&quot; title=&quot;MySQL的事务和数据恢复&quot;&gt;&lt;/a&gt;MySQL的事务和数据恢复&lt;/h1&gt;&lt;h2 id=&quot;并发事务带来的问题&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://blog.mufeng.tech/public/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="https://blog.mufeng.tech/public/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码解析</title>
    <link href="https://blog.mufeng.tech/public/2020/06/18/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.mufeng.tech/public/2020/06/18/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-06-18T10:21:27.000Z</published>
    <updated>2020-06-18T10:22:21.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap源码解析"><a href="#ConcurrentHashMap源码解析" class="headerlink" title="ConcurrentHashMap源码解析"></a>ConcurrentHashMap源码解析</h1><h2 id="ConcurrentHashMap是什么？"><a href="#ConcurrentHashMap是什么？" class="headerlink" title="ConcurrentHashMap是什么？"></a>ConcurrentHashMap是什么？</h2><p>它是对HashMap线程安全性的增强类，保证了Map对象在多线程环境下的读写的线程安全性。在使用方法上和HashMap保持一致，都是Map接口的实现类。</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/18/9b2daqDHfTItKMc.png" alt="ConcurrentHashMap"></p><h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><p>核心数据结构和HashMap相同，都是采用数组链表或数组红黑树的结构<br><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/25/YmSLJGAnVx5qUsz.png" alt=""></p><h2 id="核心源码解读（源码来自JDK11）"><a href="#核心源码解读（源码来自JDK11）" class="headerlink" title="核心源码解读（源码来自JDK11）"></a>核心源码解读（源码来自JDK11）</h2><h3 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h3><p>initTable()方法用于核心数据结构对象数组的初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Table初始化和扩容时的控制，-1为正在有线程对其进行初始化；-N 说明有N-1个线程正在进行扩容；大于等于0的情况表示table的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe U = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">  <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断是否有其他线程在进行初始化操作</span></span><br><span class="line">    <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 放弃线程竞争，仅空转</span></span><br><span class="line">      Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用Java内部的本地方法，比较SIZECTL与预期值sc是否相同，相同的话，将sizeCtl更新为-1，成功返回true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 算得初始化容量n</span></span><br><span class="line">          <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">          <span class="comment">// 初始化Node数组</span></span><br><span class="line">          <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">          Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">          <span class="comment">// 将初始化好的Node数组赋值给table成员变量</span></span><br><span class="line">          table = tab = nt;</span><br><span class="line">          <span class="comment">// sc = n * (3/4); sc变为原来的0.75倍，对应默认的负载因子。表示下次扩容的触发的真实元素个数</span></span><br><span class="line">          sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 设置sizeCtl为sc</span></span><br><span class="line">        sizeCtl = sc;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">// 计算当前键的hash</span></span><br><span class="line">  <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">  <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 循环阻塞当前执行栈，直到满足跳出条件</span></span><br><span class="line">  <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    <span class="comment">// 定位到的头元素f</span></span><br><span class="line">    Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">    <span class="comment">// 如果当前的table是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 自旋CAS初始化数组</span></span><br><span class="line">      tab = initTable();</span><br><span class="line">    <span class="comment">// 使用hash与数组长度取模，获取指定位置的桶</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 桶的位置是空的情况，直接放入新元素</span></span><br><span class="line">      <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">        <span class="comment">// 加完后直接跳出</span></span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">      <span class="comment">// 桶元素的hash是否为-1，表示当前对象正在被其他线程扩容，当前线程协助其他线程加快扩容速度</span></span><br><span class="line">      tab = helpTransfer(tab, f);</span><br><span class="line">    <span class="comment">// 桶元素的hash、key是否和待put的元素是否相等，如果相等就没必要加了，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">             &amp;&amp; fh == hash</span><br><span class="line">             &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">             &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> fv;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      V oldVal = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 对桶元素进行同步操作协调</span></span><br><span class="line">      <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">          <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 该桶为一个链表</span></span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 遍历该链表的操作，和待put的元素的hash和key进行比较</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">              K ek;</span><br><span class="line">              <span class="comment">// 如果存在则替换</span></span><br><span class="line">              <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                  ((ek = e.key) == key ||</span><br><span class="line">                   (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                oldVal = e.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                  e.val = value;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              Node&lt;K,V&gt; pred = e;</span><br><span class="line">              <span class="comment">// 不存在的话，用在链表的末尾加入当前元素</span></span><br><span class="line">              <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 是红黑树的结构</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                  value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              oldVal = p.val;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果链表节点长度大于等于树化阈值将链表转换为红黑二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">          treeifyBin(tab, i);</span><br><span class="line">        <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> oldVal;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 如果 table 不是空 且 node 节点是转移类型，数据检验</span></span><br><span class="line">    <span class="comment">// 且 node 节点的 nextTable（新 table） 不是空，同样也是数据校验</span></span><br><span class="line">    <span class="comment">// 尝试帮助扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据 length 得到一个标识符号</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">// 如果 nextTab 没有被并发修改 且 tab 也没有被并发修改</span></span><br><span class="line">        <span class="comment">// 且 sizeCtl  &lt; 0 （说明还在扩容）</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 sizeCtl 无符号右移  16 不等于 rs （ sc前 16 位如果不等于标识符，则标识符变化了）</span></span><br><span class="line">            <span class="comment">// 或者 sizeCtl == rs + 1  （扩容结束了，不再有线程进行扩容）（默认第一个线程设置 sc ==rs 左移 16 位 + 2，当第一个线程结束扩容了，就会将 sc 减一。这个时候，sc 就等于 rs + 1）</span></span><br><span class="line">            <span class="comment">// 或者 sizeCtl == rs + 65535  （如果达到最大帮助线程的数量，即 65535）</span></span><br><span class="line">            <span class="comment">// 或者转移下标正在调整 （扩容结束）</span></span><br><span class="line">            <span class="comment">// 结束循环，返回 table</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果以上都不是, 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 进行转移</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="comment">// 结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">  <span class="comment">// 计算key的hash值</span></span><br><span class="line">  <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">          <span class="comment">// 桶元素的hash等于当前key的hash, key也相等的情况下找到目标元素</span></span><br><span class="line">      <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">        <span class="keyword">return</span> e.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正在扩容或者是红黑树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 沿链表寻找hash和key匹配的元素，匹配到就返回</span></span><br><span class="line">    <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">          ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">        <span class="keyword">return</span> e.val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ConcurrentHashMap" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ConcurrentHashMap</a></li><li><a href="https://www.jianshu.com/p/39b747c99d32" target="_blank" rel="noopener">https://www.jianshu.com/p/39b747c99d32</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ConcurrentHashMap源码解析&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap源码解析&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap源码解析&quot;&gt;&lt;/a&gt;ConcurrentHashMap源码解析&lt;/
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://blog.mufeng.tech/public/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://blog.mufeng.tech/public/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Feign在实际项目中的应用实践总结</title>
    <link href="https://blog.mufeng.tech/public/2020/06/11/Feign%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.mufeng.tech/public/2020/06/11/Feign%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-11T02:59:17.000Z</published>
    <updated>2020-06-11T07:38:37.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Feign在实际项目中的应用实践总结"><a href="#Feign在实际项目中的应用实践总结" class="headerlink" title="Feign在实际项目中的应用实践总结"></a>Feign在实际项目中的应用实践总结</h1><h2 id="Feign是什么？"><a href="#Feign是什么？" class="headerlink" title="Feign是什么？"></a>Feign是什么？</h2><blockquote><p>是一个声明式的HTTP请求处理库，可以将命令式的http请求的编程，更改为声明式的http请求编程。</p></blockquote><p>下面是传统的命令式编程模式和Feign所代表的声明式编程模式的对比，可以清晰的看到声明式的代码逻辑比命令式更加的简洁，就像本地调用一样。</p><p>命令式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    CloseableHttpResponse httpResponse = </span><br><span class="line">      httpClientTool.doGet(<span class="string">"https://api.github.com//repos/"</span> + owner +<span class="string">"/"</span>+ repo +<span class="string">"/contributors"</span>);</span><br><span class="line">    String responseBody = EntityUtils.toString(httpResponse.getEntity());</span><br><span class="line">    List&lt;Contributor&gt; contributors = JsonTool.parseArray(responseBody, Contributor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /repos/&#123;owner&#125;/&#123;repo&#125;/issues"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createIssue</span><span class="params">(Issue issue, @Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                         .target(GitHub.class, "https://api.github.com");</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">    List&lt;Contributor&gt; contributors = github.contributors(<span class="string">"OpenFeign"</span>, <span class="string">"feign"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的对比中可以看到。通过命令式的http请求编程，过程复杂需要编码请求以及请求请求参数的定义，以及响应结果的字符串解析为Java对象的全过程。但声明式的http请求编程，只要事先定义好一个请求的模板（interface）剩下来的就直接交给Feign通过动态代理，将请求的细节托管不需要编码者处理具体的请求逻辑。</p><h2 id="Feign可以帮我解决什么问题，有什么优点？"><a href="#Feign可以帮我解决什么问题，有什么优点？" class="headerlink" title="Feign可以帮我解决什么问题，有什么优点？"></a>Feign可以帮我解决什么问题，有什么优点？</h2><p>Feign可以让我们书写http请求代码时更加容易，这也是他官方给Feign这个库的定义</p><blockquote><p>Feign makes writing java http clients easier</p></blockquote><p>声明式编程和命令式编程相比的优点</p><ol><li>通过接口进行http请求的定义，可以做到集中管理请求，而且不用编写请求的细节。</li><li>通过http请求的控制反转将http请求的细节交给Feign来完成，提高的请求编码的稳定性和可靠性。</li><li>通过使用动态代理和基于注解的模板模式的设计，使请求编码的代码量大幅缩减，减少重复代码，提高开发效率。</li></ol><h3 id="什么情况下不适合使用Feign？"><a href="#什么情况下不适合使用Feign？" class="headerlink" title="什么情况下不适合使用Feign？"></a>什么情况下不适合使用Feign？</h3><p>Feign也不是所有场景下都适用的，比如在请求地址不确定，参数不确定的编程的业务场景中，Feign这种需要预先定义好请求路径和目标主机地址的声明式模板反而会让代码灵活性的降低。这种场景下不适合Feign的使用，请选择命令式的http编程模式。</p><h2 id="Feign是如何实现声明式的HTTP请求定义的？"><a href="#Feign是如何实现声明式的HTTP请求定义的？" class="headerlink" title="Feign是如何实现声明式的HTTP请求定义的？"></a>Feign是如何实现声明式的HTTP请求定义的？</h2><ol><li>通过动态代理技术根据用户定义的接口自动生成代理类来执行具体的请求操作</li><li>Feign只提供了HTTP客户端的接口抽象而并没有实现HTTP客户端的具体实现，所以说Feign并不是一个HTTP请求客户端，而需要和常用的HTTP请求客户端进行组合使用，其目的是简化HTTP客户端的使用</li><li>提供序列化和反序列化的接口抽象，使用者可以按照自己的需求灵活的指定具体的序列化和反序列化实现类库</li><li>支持指标监控和常用熔断器的集成</li><li>支持多种Restful接口的定义规范，可以和已有微服务架构进行良好的集成</li></ol><h2 id="Spring项目如何整合进Feign？"><a href="#Spring项目如何整合进Feign？" class="headerlink" title="Spring项目如何整合进Feign？"></a>Spring项目如何整合进Feign？</h2><p>常用的基础依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.github.openfeign/feign-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.github.openfeign/feign-jackson --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.github.openfeign/feign-httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先需要<code>feign-cor</code>引入核心代码，<code>feign-jackson</code>基于JSON的Restful接口的的序列化和反序列化工具库，<code>feign-httpclient</code>Feign集成Apach-Http-Client作为请求的具体客户端实现。</p><p>这里需要注意，如果项目不是基于Spring-Cloud的项目的微服务，不建议直接使用 <code>spring-cloud-starter-openfeign</code>，虽然他用起来很方便，可以实现自动配置，但不利于Feign和HTTP请求客户端的细节把控，而且会引入需要没必要的依赖。简单的项目直接使用核心jar包就可以了。</p><h3 id="定义声明式接口"><a href="#定义声明式接口" class="headerlink" title="定义声明式接口"></a>定义声明式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHub</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  <span class="function">List&lt;Contributor&gt; <span class="title">contributors</span><span class="params">(@Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestLine</span>(<span class="string">"POST /repos/&#123;owner&#125;/&#123;repo&#125;/issues"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">createIssue</span><span class="params">(Issue issue, @Param(<span class="string">"owner"</span>)</span> String owner, @<span class="title">Param</span><span class="params">(<span class="string">"repo"</span>)</span> String repo)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据类型定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Contributor</span> </span>&#123;</span><br><span class="line">  String login;</span><br><span class="line">  <span class="keyword">int</span> contributions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据类型定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Issue</span> </span>&#123;</span><br><span class="line">  String title;</span><br><span class="line">  String body;</span><br><span class="line">  List&lt;String&gt; assignees;</span><br><span class="line">  <span class="keyword">int</span> milestone;</span><br><span class="line">  List&lt;String&gt; labels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置并生成一个代理类对象"><a href="#配置并生成一个代理类对象" class="headerlink" title="配置并生成一个代理类对象"></a>配置并生成一个代理类对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientConfig</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 系统中有默认jackson对象直接拿来用</span></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> ObjectMapper jacksonMapper;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ApacheHttpClient <span class="title">apacheHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以定义httpclient的具体配置</span></span><br><span class="line">    CloseableHttpClient httpClinet = HttpClients.custom().build();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApacheHttpClient(httpClinet);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JacksonDecoder <span class="title">jacksonDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以直接使用SpringBoot自带的jackson作为反序列化器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JacksonDecoder(jacksonMapper);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JacksonEncoder <span class="title">jacksonEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里可以直接使用SpringBoot自带的jackson作为序列化器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JacksonEncoder(jacksonMapper);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 生成一个实现GitHub这个接口的了代理对象并将其注入为一个Spring的Bean</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GitHub <span class="title">gitHubFeignClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ApacheHttpClient apacheHttpClient,</span></span></span><br><span class="line"><span class="function"><span class="params">    JacksonEncoder jacksonEncoder,</span></span></span><br><span class="line"><span class="function"><span class="params">    JacksonDecoder jacksonDecoder</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Feign.builder()</span><br><span class="line">        <span class="comment">// 自定义请求客户端</span></span><br><span class="line">        .client(apacheHttpClient)</span><br><span class="line">        <span class="comment">// 自定义请求体序列化器</span></span><br><span class="line">        .encoder(jacksonEncoder)</span><br><span class="line">        <span class="comment">// 自定义响应体反序列化器</span></span><br><span class="line">        .decoder(jacksonDecoder)</span><br><span class="line">        <span class="comment">// 定义目标主机</span></span><br><span class="line">        .target(GitHub.class, "https://api.github.com");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    GitHub github = Feign.builder()</span><br><span class="line">                         .decoder(<span class="keyword">new</span> GsonDecoder())</span><br><span class="line">                         .target(GitHub.class, "https://api.github.com");</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch and print a list of the contributors to this library.</span></span><br><span class="line">    List&lt;Contributor&gt; contributors = github.contributors(<span class="string">"OpenFeign"</span>, <span class="string">"feign"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Contributor contributor : contributors) &#123;</span><br><span class="line">      System.out.println(contributor.login + <span class="string">" ("</span> + contributor.contributions + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何自定义底层HTTP客户端的实现？"><a href="#如何自定义底层HTTP客户端的实现？" class="headerlink" title="如何自定义底层HTTP客户端的实现？"></a>如何自定义底层HTTP客户端的实现？</h2><p>要自定义HTTP客户端的实现，可以通过<code>Feign.builder().client()</code>的方法来指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Feign.<span class="function">Builder <span class="title">client</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.client = client;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到自定义的Client实例需要实现Client接口</p><p>所以我们需要使用依赖jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查看类的内部，ApacheHttpClient实现了Client接口，并且有一个使用HttpClient类作为参数的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApacheHttpClient</span> <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ApacheHttpClient</span><span class="params">(HttpClient client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们只需要通过ApacheHttpClient的构造函数传入HttpClient的实例对象，就可以完成Feign和HttpClient的适配工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Feign.builder().client(<span class="keyword">new</span> ApacheHttpClient(httpClientInstance));</span><br></pre></td></tr></table></figure><h2 id="如何实现全局HTTP请求的统一-tracer-日志？"><a href="#如何实现全局HTTP请求的统一-tracer-日志？" class="headerlink" title="如何实现全局HTTP请求的统一 tracer 日志？"></a>如何实现全局HTTP请求的统一 tracer 日志？</h2><p>在企业应用场景中，统一的HTTP的Tracer是非常有必要的。为什么？往小了说可以帮你定位问题，往大了说就能保住你饭碗。通常的一个Web系统，都会接入其他三方的资源和服务来扩充自己的服务能力，而常用的接入方案就是Rest接口。而三方的服务你是没办法保证的，只能保证自己的服务是没有问题的。在线上如果出现服务调用失败，统一的Tracer日志可进行错误的定位，是三方的服务接口出问题还是自己的代码写的有问题。在很多情况下，自己做为服务提供者，往往在出现问题后客户会要求查看接口请求日志。如果没有做HTTP的统一Tracer日志，只能空口评说了，搞不好饭碗都丢了。总之一句话，系统和系统交互的边界上一定要打日志，一定要打日志，一定要打日志（重要的事情说三遍！）</p><h3 id="那如何给Feign接入统一的日志呢？"><a href="#那如何给Feign接入统一的日志呢？" class="headerlink" title="那如何给Feign接入统一的日志呢？"></a>那如何给Feign接入统一的日志呢？</h3><p>根据官方文档，Feign是支持Logger配置的，使用者可以选择适合自己的Logger进行请求日志的记录。但是Feign的日志打印有一个很严重的问题，他是分步打印的。也就是说一个HTTP请求，请求发起打印一行，请求结束打印一行。想想这会发生什么事情？</p><p>在系统打规模并发的情况下，一个请求的发起阶段和响应阶段的日志并不是在一起的，中间可能穿插着其他请求的日志记录。当我们需要去追溯日志的时候，发现根本没有办法定位到哪一个请求出了问题，只能找到请求的某一个阶段的日志。</p><p>现在有几个需求需要实现。</p><ol><li>将请求的请求阶段的数和响应阶段的数据放在同一行日志中</li><li>每个请求都会带有唯一的请求ID，服务调用过程中都会携带这个请求ID</li></ol><p>实现方式就是使用HttpClient的请求拦截器和响应拦截器进行对请求的拦截。HttpClient在请求过程中有一个请求级别的对象，RequestContext。这个对象在整个请求的生命周期中都可以访问和读写。那我们可以使用这个请求上下文对象用来记录请求过程中的参数</p><h3 id="请求日志记录的代码实现"><a href="#请求日志记录的代码实现" class="headerlink" title="请求日志记录的代码实现"></a>请求日志记录的代码实现</h3><p>先定义我们的请求日志需要记录请求生命周期的哪些字段？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http请求日志字段枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HttpLogEnum &#123;</span><br><span class="line">        protocolVersion,</span><br><span class="line">        method,</span><br><span class="line">        url,</span><br><span class="line">        requestHeaders,</span><br><span class="line">        requestBody,</span><br><span class="line">        responseHeaders,</span><br><span class="line">        responseCode,</span><br><span class="line">        responseBody</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义请求拦截器，将请求阶段需要记录的参数绑定到请求上下文对象上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现HttpRequestInterceptor请求拦截器接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestInterceptor</span> <span class="keyword">implements</span> <span class="title">HttpRequestInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现process方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpRequest httpRequest, HttpContext httpContext)</span> <span class="keyword">throws</span> HttpException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 先将请求对象 httpRequest 进行包装操作方便获取请求阶段数据</span></span><br><span class="line">    <span class="keyword">final</span> HttpRequestWrapper httpRequestWrapper = HttpRequestWrapper.wrap(httpRequest);</span><br><span class="line">    <span class="comment">// 获取请求的协议版本</span></span><br><span class="line">    httpContext.setAttribute(HttpLogEnum.protocolVersion.name(), httpRequestWrapper.getProtocolVersion().toString());</span><br><span class="line">    <span class="comment">// 获取请求的Method(GET、POST、PUT...)</span></span><br><span class="line">    httpContext.setAttribute(HttpLogEnum.method.name(), httpRequestWrapper.getMethod());</span><br><span class="line">    <span class="comment">// 请求的url</span></span><br><span class="line">    httpContext.setAttribute(HttpLogEnum.url.name(), httpRequestWrapper.getURI().toString());</span><br><span class="line">    <span class="comment">// 请求的请求头</span></span><br><span class="line">    httpContext.setAttribute(HttpLogEnum.requestHeaders.name(), getHeaderMap(httpRequestWrapper.getAllHeaders()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求的请求体</span></span><br><span class="line">    <span class="keyword">if</span> (httpRequestWrapper <span class="keyword">instanceof</span> HttpEntityEnclosingRequest) &#123;</span><br><span class="line">      <span class="keyword">final</span> HttpEntity entity = ((HttpEntityEnclosingRequest) httpRequestWrapper).getEntity();</span><br><span class="line">      String content = EntityUtils.toString(entity, ENCODING);</span><br><span class="line">      httpContext.setAttribute(HttpLogEnum.requestBody.name(), content);</span><br><span class="line">      <span class="comment">// 由于请求体前面已被读取，读取后需要重新写入请求体</span></span><br><span class="line">      ((HttpEntityEnclosingRequest) httpRequest).setEntity(<span class="keyword">new</span> StringEntity(content, ContentType.get(entity)));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有携带请求体的请求</span></span><br><span class="line">      httpContext.setAttribute(HttpLogEnum.requestBody.name(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义响应拦截器，获取响应的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现HttpResponseInterceptor响应拦截接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseInterceptor</span> <span class="keyword">implements</span> <span class="title">HttpResponseInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpResponse httpResponse, HttpContext httpContext)</span> <span class="keyword">throws</span> HttpException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取响应头</span></span><br><span class="line">    httpContext.setAttribute(HttpLogEnum.responseHeaders.name(), getHeaderMap(httpResponse.getAllHeaders()));</span><br><span class="line">    <span class="comment">// 获取HTTP响应码</span></span><br><span class="line">    httpContext.setAttribute(HttpLogEnum.responseCode.name(), httpResponse.getStatusLine().getStatusCode());</span><br><span class="line">    <span class="keyword">final</span> HttpEntity entity = httpResponse.getEntity();</span><br><span class="line">    String responseBody = EntityUtils.toString(entity, ENCODING);</span><br><span class="line">    <span class="comment">// 获取请求的响应体</span></span><br><span class="line">    httpContext.setAttribute(HttpLogEnum.responseBody.name(), responseBody);</span><br><span class="line">    <span class="comment">// 重新写入响应体</span></span><br><span class="line">    httpResponse.setEntity(<span class="keyword">new</span> StringEntity(responseBody, ContentType.get(entity)));</span><br><span class="line">    <span class="comment">// 将httpContext对象保存的字段进行获取包装成一个Map对象</span></span><br><span class="line">    Map&lt;String, Object&gt; log = <span class="keyword">new</span> HashMap&lt;&gt;(HttpLogEnum.values().length);</span><br><span class="line">    <span class="comment">// 进行字段的读取</span></span><br><span class="line">    <span class="keyword">for</span> (HttpLogEnum item : HttpLogEnum.values()) &#123;</span><br><span class="line">      log.put(item.name(), httpContext.getAttribute(item.name()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过json工具对Map序列化成json文本，并通过标准输出进行打印</span></span><br><span class="line">    System.out.println(JsonUtil.toJson(log));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将请求/响应拦截器绑定到HttpClient对象上，并注册到Spring的容器中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClinetConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">httpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HttpClients.custom()</span><br><span class="line">                  <span class="comment">// 请求日志拦截器</span></span><br><span class="line">                .addInterceptorFirst(<span class="keyword">new</span> RequestInterceptor())</span><br><span class="line">                  <span class="comment">// 响应日志拦截器</span></span><br><span class="line">                .addInterceptorFirst(<span class="keyword">new</span> ResponseInterceptor())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将HttpClient指定为Feign的客户端实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">.....其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注入HttpClient的Bean</span></span><br><span class="line">  <span class="meta">@Resource</span></span><br><span class="line">  <span class="keyword">private</span> CloseableHttpClient httpClinet;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ApacheHttpClient <span class="title">apacheHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将HttpClient包装成Feign的ApacheHttpClient</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ApacheHttpClient(httpClinet);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 生成一个实现GitHub这个接口的了代理对象并将其注入为一个Spring的Bean</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GitHub <span class="title">gitHubFeignClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ApacheHttpClient apacheHttpClient,</span></span></span><br><span class="line"><span class="function"><span class="params">    JacksonEncoder jacksonEncoder,</span></span></span><br><span class="line"><span class="function"><span class="params">    JacksonDecoder jacksonDecoder</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Feign.builder()</span><br><span class="line">        <span class="comment">// 设置上面定义的请求客户端实现</span></span><br><span class="line">        .client(apacheHttpClient)</span><br><span class="line">        <span class="comment">// 自定义请求体序列化器</span></span><br><span class="line">        .encoder(jacksonEncoder)</span><br><span class="line">        <span class="comment">// 自定义响应体反序列化器</span></span><br><span class="line">        .decoder(jacksonDecoder)</span><br><span class="line">        <span class="comment">// 定义目标主机</span></span><br><span class="line">        .target(GitHub.class, "https://api.github.com");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何集成指标监控？以及数据的收集工作？"><a href="#如何集成指标监控？以及数据的收集工作？" class="headerlink" title="如何集成指标监控？以及数据的收集工作？"></a>如何集成指标监控？以及数据的收集工作？</h2><p>增加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-micrometer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置指标收集器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientBuilder</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 其他代码  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注入actuator的指标注册器</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> MeterRegistry meterRegistry;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将meterRegistry包装成feign的MicrometerCapability类</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MicrometerCapability <span class="title">micrometerCapability</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MicrometerCapability(meterRegistry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BananaFeignClient <span class="title">bananaFeignClient</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ApacheHttpClient apacheHttpClient,</span></span></span><br><span class="line"><span class="function"><span class="params">            JacksonEncoder jacksonEncoder,</span></span></span><br><span class="line"><span class="function"><span class="params">            JacksonDecoder jacksonDecoder,</span></span></span><br><span class="line"><span class="function"><span class="params">      MicrometerCapability micrometerCapability</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Feign.builder()</span><br><span class="line">          <span class="comment">// 将micrometerCapability绑定到Feign上</span></span><br><span class="line">                .addCapability(micrometerCapability)</span><br><span class="line">                .client(apacheHttpClient)</span><br><span class="line">                .encoder(jacksonEncoder)</span><br><span class="line">                .decoder(jacksonDecoder)</span><br><span class="line">                .target(BananaFeignClient<span class="class">.<span class="keyword">class</span>, <span class="title">bananaHost</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加actuator配置暴露metrics端点，不配置的话默认使用 health和info端点暴露</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">httptrace</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">info</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">health</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">metrics</span></span><br></pre></td></tr></table></figure><p>重启服务后，查看<a href="http://localhost:8080/actuator/metrics" target="_blank" rel="noopener">http://localhost:8080/actuator/metrics</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"names"</span>: [</span><br><span class="line">        <span class="string">"jvm.buffer.count"</span>,</span><br><span class="line">        <span class="string">"jvm.buffer.memory.used"</span>,</span><br><span class="line">        <span class="string">"jvm.buffer.total.capacity"</span>,</span><br><span class="line">        <span class="string">"jvm.classes.loaded"</span>,</span><br><span class="line">        <span class="string">"jvm.classes.unloaded"</span>,</span><br><span class="line">        <span class="string">"jvm.gc.live.data.size"</span>,</span><br><span class="line">        <span class="string">"jvm.gc.max.data.size"</span>,</span><br><span class="line">        <span class="string">"jvm.gc.memory.allocated"</span>,</span><br><span class="line">        <span class="string">"jvm.gc.memory.promoted"</span>,</span><br><span class="line">        <span class="string">"jvm.gc.pause"</span>,</span><br><span class="line">        <span class="string">"jvm.memory.committed"</span>,</span><br><span class="line">        <span class="string">"jvm.memory.max"</span>,</span><br><span class="line">        <span class="string">"jvm.memory.used"</span>,</span><br><span class="line">        <span class="string">"jvm.threads.daemon"</span>,</span><br><span class="line">        <span class="string">"jvm.threads.live"</span>,</span><br><span class="line">        <span class="string">"jvm.threads.peak"</span>,</span><br><span class="line">        <span class="string">"jvm.threads.states"</span>,</span><br><span class="line">        <span class="string">"logback.events"</span>,</span><br><span class="line">        <span class="string">"process.cpu.usage"</span>,</span><br><span class="line">        <span class="string">"process.files.max"</span>,</span><br><span class="line">        <span class="string">"process.files.open"</span>,</span><br><span class="line">        <span class="string">"process.start.time"</span>,</span><br><span class="line">        <span class="string">"process.uptime"</span>,</span><br><span class="line">        <span class="string">"system.cpu.count"</span>,</span><br><span class="line">        <span class="string">"system.cpu.usage"</span>,</span><br><span class="line">        <span class="string">"system.load.average.1m"</span>,</span><br><span class="line">        <span class="string">"tomcat.sessions.active.current"</span>,</span><br><span class="line">        <span class="string">"tomcat.sessions.active.max"</span>,</span><br><span class="line">        <span class="string">"tomcat.sessions.alive.max"</span>,</span><br><span class="line">        <span class="string">"tomcat.sessions.created"</span>,</span><br><span class="line">        <span class="string">"tomcat.sessions.expired"</span>,</span><br><span class="line">        <span class="string">"tomcat.sessions.rejected"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现并没有Feign相关的指标，因为没有发起过请求，所以没有数据。我们先发起一下请求后看到</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"names"</span>: [</span><br><span class="line">        <span class="string">"feign.Client"</span>,</span><br><span class="line">        <span class="string">"feign.Feign"</span>,</span><br><span class="line">        <span class="string">"feign.codec.Decoder"</span>,</span><br><span class="line">        <span class="string">"feign.codec.Decoder.response_size"</span>,</span><br><span class="line">        ......</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多了Feign相关的指标</p><p>查看指标细节 <a href="http://localhost:8080/actuator/metrics/feign.Client" target="_blank" rel="noopener">http://localhost:8080/actuator/metrics/feign.Client</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"feign.Client"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"baseUnit"</span>: <span class="string">"seconds"</span>,</span><br><span class="line">    <span class="attr">"measurements"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"statistic"</span>: <span class="string">"COUNT"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"statistic"</span>: <span class="string">"TOTAL_TIME"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">0.169881274</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"statistic"</span>: <span class="string">"MAX"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="number">0.043015818</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"availableTags"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"method"</span>,</span><br><span class="line">            <span class="attr">"values"</span>: [</span><br><span class="line">                <span class="string">"validateUserToken"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"host"</span>,</span><br><span class="line">            <span class="attr">"values"</span>: [</span><br><span class="line">                <span class="string">"blog.mufeng.tech"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"tag"</span>: <span class="string">"client"</span>,</span><br><span class="line">            <span class="attr">"values"</span>: [</span><br><span class="line">                <span class="string">"tech.mufeng.feign.defined.ExampleFeignClient"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接入prometheus监控后就能集成监控和报警的功能</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">Feign开源项目仓库地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Feign在实际项目中的应用实践总结&quot;&gt;&lt;a href=&quot;#Feign在实际项目中的应用实践总结&quot; class=&quot;headerlink&quot; title=&quot;Feign在实际项目中的应用实践总结&quot;&gt;&lt;/a&gt;Feign在实际项目中的应用实践总结&lt;/h1&gt;&lt;h2 id=&quot;F
      
    
    </summary>
    
    
      <category term="应用总结" scheme="https://blog.mufeng.tech/public/categories/%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Feign" scheme="https://blog.mufeng.tech/public/tags/Feign/"/>
    
      <category term="HttpClient" scheme="https://blog.mufeng.tech/public/tags/HttpClient/"/>
    
      <category term="指标监控" scheme="https://blog.mufeng.tech/public/tags/%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Spring" scheme="https://blog.mufeng.tech/public/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList并发List容器源码解析</title>
    <link href="https://blog.mufeng.tech/public/2020/06/03/CopyOnWriteArrayList%E5%B9%B6%E5%8F%91List%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.mufeng.tech/public/2020/06/03/CopyOnWriteArrayList%E5%B9%B6%E5%8F%91List%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2020-06-03T05:05:30.000Z</published>
    <updated>2020-06-03T05:11:30.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CopyOnWriteArrayList并发List容器源码解析"><a href="#CopyOnWriteArrayList并发List容器源码解析" class="headerlink" title="CopyOnWriteArrayList并发List容器源码解析"></a>CopyOnWriteArrayList并发List容器源码解析</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/03/DMNYK4aiehxZw2j.png" alt="CopyOnWriteArrayList源码分析"></p><blockquote><p>备注：下面的源码拷贝自JDK11</p></blockquote><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/03/hDuVYLAiBd74gln.png" alt="CopyOnWriteArrayList"></p><h3 id="实现的接口"><a href="#实现的接口" class="headerlink" title="实现的接口"></a>实现的接口</h3><ul><li>Serializable：支持对象的序列化</li><li>Cloneable：支持对象的复制</li><li>RandomAccess：支持通过索引的随机访问</li><li>List：支持List的所有操作</li></ul><h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><p>由下面的源码实现上来看，内部还是使用和ArrayList相同的普通对象数组。而且可以看到，相较于ArrayList增加了一个对象的实例锁<code>lock</code>，使用<code>synchronized</code>关键字给增删改上锁，后面的源码样例可以更加详细的看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The lock protecting all mutators.  (We have a mild preference</span></span><br><span class="line"><span class="comment">  * for builtin monitors over ReentrantLock when either will do.)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">transient</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="COWIterator"><a href="#COWIterator" class="headerlink" title="COWIterator"></a>COWIterator</h4><p>CopyOnWriteArrayList的内部迭代器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">    COWIterator(Object[] es, <span class="keyword">int</span> initialCursor) &#123;</span><br><span class="line">       cursor = initialCursor;</span><br><span class="line">       snapshot = es;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//.........</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CopyOnWriteArrayList的iterator方法返回一个迭代器实例就是COWIterator类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="COWSubList"><a href="#COWSubList" class="headerlink" title="COWSubList"></a>COWSubList</h4><p>CopyOnWriteArrayList内部子列表视图</p><p>用于返回内部某一个时刻的数组的一个字视图，子列表视图的部分的，增删改查都用到了CopyOnWriteArrayList的实例锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">COWSubList</span> <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">private</span> Object[] expectedArray;</span><br><span class="line"></span><br><span class="line">    COWSubList(Object[] es, <span class="keyword">int</span> offset, <span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="comment">// assert Thread.holdsLock(lock);</span></span><br><span class="line">        expectedArray = es;</span><br><span class="line">        <span class="keyword">this</span>.offset = offset;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 可以看到子列表的改操作用到实例锁</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E x = CopyOnWriteArrayList.<span class="keyword">this</span>.set(offset + index, element);</span><br><span class="line">        expectedArray = getArray();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读操作用到实例锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> CopyOnWriteArrayList.<span class="keyword">this</span>.get(offset + index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读操作用到实例锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加操作用到实例锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        CopyOnWriteArrayList.<span class="keyword">this</span>.add(offset + size, element);</span><br><span class="line">        expectedArray = getArray();</span><br><span class="line">        size++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删操作用到了实例锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = CopyOnWriteArrayList.<span class="keyword">this</span>.remove(offset + index);</span><br><span class="line">        expectedArray = getArray();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="COWSubListIterator"><a href="#COWSubListIterator" class="headerlink" title="COWSubListIterator"></a>COWSubListIterator</h4><p>子列表视图迭代器，可以看到实现了ListIterator接口，作用和COWIterator类似，用于迭代访问数组某一个时刻的切片</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">COWSubListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ListIterator&lt;E&gt; it;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">  COWSubListIterator(List&lt;E&gt; l, <span class="keyword">int</span> index, <span class="keyword">int</span> offset, <span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    it = l.listIterator(index + offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写线程安全的实现原理"><a href="#读写线程安全的实现原理" class="headerlink" title="读写线程安全的实现原理"></a>读写线程安全的实现原理</h2><p>先给出语言描述，CopyOnWriteArrayList线程安全的实现原理简单来说就是：当进行增删改操作时候，通过<code>synchronized</code>修饰操作方法中的对象锁lock。然后对原数组进行复制，复制出一份和原数组一模一样的拷贝，然后在拷贝上进行增删改操作。操作完成后用新的拷贝代替原数组。然后解锁，就实现了多线程间安全的操作同一个List实例。</p><p>对于读操作，不上锁，随便读。这就是CopyOnWriteArrayList适合读多写少的场景的原因</p><h3 id="读操作源码"><a href="#读操作源码" class="headerlink" title="读操作源码"></a>读操作源码</h3><p>可以看到，对于读操作是最简单的实现。没有上任何的锁机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> elementAt(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没错就是你看到的这么简单，直接通过索引读取对应位置的元素</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">E <span class="title">elementAt</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加操作源码"><a href="#增加操作源码" class="headerlink" title="增加操作源码"></a>增加操作源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用synchronized对lock对象锁上锁，所以多线程的修改操作都是互斥的。同时也避免了多线程写时复制出多个副本出来</span></span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 1.取原数组</span></span><br><span class="line">    Object[] es = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = es.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.拷贝一份新的数组实例，长度+1</span></span><br><span class="line">    es = Arrays.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.将新的元素放在数组的最后面</span></span><br><span class="line">    es[len] = e;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 4.用新的数组代替老数组</span></span><br><span class="line">    setArray(es);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">  array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换操作源码"><a href="#替换操作源码" class="headerlink" title="替换操作源码"></a>替换操作源码</h3><p>替换操作的逻辑和增加操作是一样的，只是做了一定的优化。先判断被替换的元素和新元素是不是一样。如果一样就没必要替换了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    Object[] es = getArray();</span><br><span class="line">    E oldValue = elementAt(es, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果老元素和新元素是同一个，就没必要替换了</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">      <span class="comment">// 拷贝一份新的数组</span></span><br><span class="line">      es = es.clone();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 替换对应位置的元素</span></span><br><span class="line">      es[index] = element;</span><br><span class="line">      setArray(es);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作源码"><a href="#删除操作源码" class="headerlink" title="删除操作源码"></a>删除操作源码</h3><p>替换操作相对复杂一点，涉及到元素的两次拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="comment">// 取原数组</span></span><br><span class="line">    Object[] es = getArray();</span><br><span class="line">    <span class="comment">// 原数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = es.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要移除位置的元素</span></span><br><span class="line">    E oldValue = elementAt(es, index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除位置元素之后的剩余数组右侧需要复制的长度</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新的空数组</span></span><br><span class="line">    Object[] newElements;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除的是原始数组的最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 直接复制到倒数第二个元素</span></span><br><span class="line">      newElements = Arrays.copyOf(es, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 长度减1的新空数组</span></span><br><span class="line">      newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将原始数组从0开始复制index个元素到新数组从0位置开始的数组中</span></span><br><span class="line">      System.arraycopy(es, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将原始数组跳过要移除的元素复制numMoved个元素到新数组从index开始的数组中</span></span><br><span class="line">      System.arraycopy(es, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(newElements);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CopyOnWriteArrayList的特点"><a href="#CopyOnWriteArrayList的特点" class="headerlink" title="CopyOnWriteArrayList的特点"></a>CopyOnWriteArrayList的特点</h2><ul><li>同时读读不加锁：读高性能</li><li>同时写写互斥：写同步</li><li>同时读写不阻塞：读写分离，互相不干预</li><li>没有像ArrayList一样的扩容机制：因为所有的修改操作都是进行对象的复制，所以没有必要引入扩容机制</li></ul><h2 id="CopyOnWriteArrayList-使用场景以及注意点"><a href="#CopyOnWriteArrayList-使用场景以及注意点" class="headerlink" title="CopyOnWriteArrayList 使用场景以及注意点"></a>CopyOnWriteArrayList 使用场景以及注意点</h2><p>从CopyOnWriteArrayList的源码实现中可以看出，为了提高列表的读写性能，对读操作是不加锁的，可以任意读。换句话说，其实多线程读同一个元素，也没必要加锁。而对增删改操作使用实例的对象锁，进行操作的同步，只需要写入和写入之间需要同步，提高整体的读写性能。</p><p>但是从实现机理上也能看出，每次的写操作都会进行数组的复制操作。如果数组长度很大的话，效率会降低。</p><h4 id="适合的应用场景"><a href="#适合的应用场景" class="headerlink" title="适合的应用场景"></a>适合的应用场景</h4><ul><li>读多写少的情况</li><li>列表规模不大的情况</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/并发容器总结?id=_32-copyonwritearraylist-是如何做到的" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/并发容器总结</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CopyOnWriteArrayList并发List容器源码解析&quot;&gt;&lt;a href=&quot;#CopyOnWriteArrayList并发List容器源码解析&quot; class=&quot;headerlink&quot; title=&quot;CopyOnWriteArrayList并发List容器
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://blog.mufeng.tech/public/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://blog.mufeng.tech/public/tags/Java/"/>
    
      <category term="并发容器" scheme="https://blog.mufeng.tech/public/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket协议详解以及服务实现的技术总结</title>
    <link href="https://blog.mufeng.tech/public/2020/06/02/WebSocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.mufeng.tech/public/2020/06/02/WebSocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-02T09:34:33.000Z</published>
    <updated>2020-06-03T00:37:07.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSocket协议详解以及WebSocket服务实现的技术总结"><a href="#WebSocket协议详解以及WebSocket服务实现的技术总结" class="headerlink" title="WebSocket协议详解以及WebSocket服务实现的技术总结"></a>WebSocket协议详解以及WebSocket服务实现的技术总结</h1><h2 id="WebSocket是什么？（下面简称ws）"><a href="#WebSocket是什么？（下面简称ws）" class="headerlink" title="WebSocket是什么？（下面简称ws）"></a>WebSocket是什么？（下面简称ws）</h2><blockquote><p>WebSocket是一种在<strong>单个TCP</strong>连接上进行<strong>全双工</strong>通信的网络传输协议。客户端与服务端完成一次握手后，两者之间可以创建持久性的连接，并进行双向数据传输。</p></blockquote><h2 id="ws技术可以解决什么样的业务场景问题？"><a href="#ws技术可以解决什么样的业务场景问题？" class="headerlink" title="ws技术可以解决什么样的业务场景问题？"></a>ws技术可以解决什么样的业务场景问题？</h2><h3 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h3><p>客户端需要持续监测服务器数据变动的业务场景下，如股票交易、抢单、即时通讯、多人协作服务等。这些业务场景对于消息的即时性有很高的要求，而且还要保证消息的可靠传递</p><h2 id="WS的技术背景"><a href="#WS的技术背景" class="headerlink" title="WS的技术背景"></a>WS的技术背景</h2><p>在ws协议出现之前，对于实时性要求高的业务场景往往采用的是基于<strong>HTTP</strong>协议的的轮询技术。也就是每隔一段时间向服务器发送请求，如果有最新的数据就返回给客户端。这种传统的模式有很明显的缺点，即客户端向服务器不断的发送请求，然而HTTP请求与回复的过程中包含很多较长的<strong>头部</strong>（因为HTTP协议是基于文本的协议），其中真正有效的数据可能只是很小的一部分，会导致消耗很多无效的带宽资源。而且消息的实时性的指标与轮询的频率成正相关，但是频率越高所消耗的带宽资源就越高，随着互联网用户规模的庞大，显然遇到了瓶颈。</p><p>对于HTTP轮询协议的改进，就出现了Comet技术。Comet中普遍采用的<a href="https://zh.wikipedia.org/wiki/HTTP持久链接" target="_blank" rel="noopener">HTTP长连接</a>也会消耗服务器资源。本质上是将HTTP连接的超时时间强制延长，来减少带宽的浪费，但本质上还是HTTP技术，需要反复的发出请求。</p><p>ws技术的出现解决了上面的问题。ws通过兼容HTTP协议常用的80和443端口来实现客户端和服务器的双向通信，可以绕过大多数防火墙的限制。</p><h2 id="ws技术的优点"><a href="#ws技术的优点" class="headerlink" title="ws技术的优点"></a>ws技术的优点</h2><ul><li>减少控制开销，消息头部只有2至10字节，相比于HTTP协议的头部明显减少</li><li>更强的实时性，由于是全双工的通道，在客户端和服务可以同时向对方发送消息，相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li><li>保持连接状态（有状态的连接），ws和http协议的不同点就是，http协议是无状态的协议，业务上为了保证连接的状态，每次进行通信都会携带状态消息（如身份认证等）。而ws协议是有状态协议，彼此之间通信无需重复传递状态消息</li><li>可以传输二进制数据，相对HTTP，可以更轻松地处理二进制内容。</li></ul><h2 id="ws的的协议细节"><a href="#ws的的协议细节" class="headerlink" title="ws的的协议细节"></a>ws的的协议细节</h2><p>ws连接的创建需要客户端首先发起请求连接，而握手请求使用的是HTTP协议。在客户端的请求头上的<strong>Upgrade</strong>字段是<strong>websocket</strong>，表明需要升级为ws协议进行通讯。服务器在收到请求后，返回101状态码表示服务理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/02/AU7RhwT5BvkrPqd.png" alt="WebSocket握手时序图"></p><h3 id="典型的握手请求"><a href="#典型的握手请求" class="headerlink" title="典型的握手请求"></a>典型的握手请求</h3><p>客户端HTTP请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line"><span class="attribute">Origin</span>: http://example.com</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><p>服务端响应</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure><h3 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h3><ul><li>Connection必须设置Upgrade，表示客户端希望连接升级</li><li>Upgrade字段必须设置Websocket，表示希望升级到Websocket协议。</li><li>Sec-WebSocket-Key是随机的字符串，服务器端会用这些数据来构造出一个SHA-1的信息摘要。把“Sec-WebSocket-Key”加上一个特殊字符串“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”，然后计算<a href="https://zh.wikipedia.org/wiki/SHA-1" target="_blank" rel="noopener">SHA-1</a>摘要，之后进行<a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64</a>编码，将结果做为“Sec-WebSocket-Accept”头的值，返回给客户端。如此操作，可以尽量避免普通HTTP请求被误认为Websocket协议。</li><li>Sec-WebSocket-Version 表示支持的Websocket版本。RFC6455要求使用的版本是13，之前草案的版本均应当弃用。</li><li>Origin字段是可选的，通常用来表示在浏览器中发起此Websocket连接所在的页面，类似于<a href="https://zh.wikipedia.org/wiki/HTTP来源地址" target="_blank" rel="noopener">Referer</a>。但是，与Referer不同的是，Origin只包含了协议和主机名称。</li><li>其他一些定义在HTTP协议中的字段，如<a href="https://zh.wikipedia.org/wiki/Cookie" target="_blank" rel="noopener">Cookie</a>等，也可以在Websocket中使用。</li></ul><h3 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h3><p>从左到右，单位是Bit，<a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="noopener">RFC6455参考，5.2章节</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16&#x2F;64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len&#x3D;&#x3D;126&#x2F;127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len &#x3D;&#x3D; 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h5 id="FIN：1bit"><a href="#FIN：1bit" class="headerlink" title="FIN：1bit"></a>FIN：1bit</h5><p>如果是1代表这是单条消息，没有后续分片了。而如果是0代表，代表此数据帧是不是一个完整的消息，而是一个消息的分片，并且不是最后一个分片后面还有其他分片</p><h5 id="RSV1-RSV2-RSV3-1-bit-each"><a href="#RSV1-RSV2-RSV3-1-bit-each" class="headerlink" title="RSV1, RSV2, RSV3:  1 bit each"></a>RSV1, RSV2, RSV3:  1 bit each</h5><p>必须是0，除非客户端和服务端使用WS扩展时，可以为非0。</p><h5 id="Opcode-4bit"><a href="#Opcode-4bit" class="headerlink" title="Opcode: 4bit"></a>Opcode: 4bit</h5><p>这个为操作码，表示对后面的有效数据荷载的具体操作，如果未知接收端需要断开连接</p><ul><li><p>％x0：表示连续帧</p></li><li><p>％x1：表示文本帧</p></li><li><p>％x2：表示二进制帧</p></li><li><p>％x3-7：保留用于其他非控制帧</p></li><li><p>％x8：表示连接关闭</p></li><li><p>％x9：表示ping操作</p></li><li><p>％xA：表示pong操作</p></li><li><p>％xB-F：保留用于其他控制帧</p></li></ul><h5 id="Mask-1bit"><a href="#Mask-1bit" class="headerlink" title="Mask:  1bit"></a>Mask:  1bit</h5><p>是否进行过掩码，比如客户端给服务端发送消息，需要进行掩码操作。而服务端到客户端不需要</p><h5 id="Payload-Length-7-bits-7-16-bits-or-7-64-bits"><a href="#Payload-Length-7-bits-7-16-bits-or-7-64-bits" class="headerlink" title="Payload Length:  7 bits, 7+16 bits, or 7+64 bits"></a>Payload Length:  7 bits, 7+16 bits, or 7+64 bits</h5><p>“有效载荷数据”的长度（以字节为单位）：如果为0-125，则为有效载荷长度。 如果为126，则以下2个字节解释为16位无符号整数是有效载荷长度。 如果是127，以下8个字节解释为64位无符号整数（最高有效位必须为0）是有效载荷长度。 多字节长度数量以网络字节顺序表示。 注意在所有情况下，必须使用最小字节数进行编码长度，例如124字节长的字符串的长度不能编码为序列126、0、124。有效载荷长度是“扩展数据”的长度+“应用程序数据”。 “扩展数据”的长度可以是零，在这种情况下，有效负载长度是 “应用程序数据”。</p><h5 id="Masking-key-0-or-4-bytes-32bit"><a href="#Masking-key-0-or-4-bytes-32bit" class="headerlink" title="Masking-key:  0 or 4 bytes (32bit)"></a>Masking-key:  0 or 4 bytes (32bit)</h5><p>所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。</p><h5 id="Payload-data-x-y-bytes"><a href="#Payload-data-x-y-bytes" class="headerlink" title="Payload data:  (x+y) bytes"></a>Payload data:  (x+y) bytes</h5><p>“有效载荷数据”定义为串联的“Extension data”与“Application data”。</p><ul><li>Extension data:  x bytes</li></ul><p>如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。</p><ul><li>Application data:  y bytes</li></ul><p>任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。</p><h2 id="spring体系下如何搭建ws服务？"><a href="#spring体系下如何搭建ws服务？" class="headerlink" title="spring体系下如何搭建ws服务？"></a>spring体系下如何搭建ws服务？</h2><p>采用SpringBoot搭建WS服务</p><h3 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h3><p>POM.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/02/lHDMrcfYRLVNhQI.png" alt=""></p><p>可以看到<code>srping-boot-starter-websocket</code>包含了<code>spring-boot-starter-web</code>，所以我们不需要再引入服务器依赖。其中还用到了，<code>spring-message</code>和<code>spring-websocket</code></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/02/ZTq4EOUHWPIz2h5.png" alt=""></p><p>可以看到<code>srping-boot-starter-websocket</code>默认使用tomcat作为web服务器，所以我们后续可以进行HTTP接口的开发</p><p>依赖搞定之后需要，进行ws服务的实现。要实现ws服务器，需要实现一下几个部分，与上面的ws通讯过程对应</p><ol><li>握手拦截处理器</li><li>消息处理器</li><li>Session管理器（可选，简单应用可以不用session管理器）</li><li>WS配置Bean</li></ol><h3 id="握手拦截处理器"><a href="#握手拦截处理器" class="headerlink" title="握手拦截处理器"></a>握手拦截处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">握手处理器，用于客户端的握手请求</span></span><br><span class="line"><span class="comment">需要实现HandshakeInterceptor接口并注册成spring的一个Bean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title">HandshakeInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOKEN = <span class="string">"token"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String CHANNEL_ID = <span class="string">"channelId"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 握手前的调用，可在这里进行请求的校验工作（如权限的校验）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">beforeHandshake</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServerHttpRequest serverHttpRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerHttpResponse serverHttpResponse, </span></span></span><br><span class="line"><span class="function"><span class="params">      WebSocketHandler webSocketHandler, </span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Object&gt; attributes)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String queryString = serverHttpRequest.getURI().getQuery();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String&gt; queryMap = mapQueryString(queryString);</span><br><span class="line">        <span class="keyword">if</span> (queryMap.containsKey(TOKEN) &amp;&amp; queryMap.containsKey(CHANNEL_ID)) &#123;</span><br><span class="line">          <span class="comment">// attributes是可以用来绑定一些自定义的数据到当前session上，在session的整个生命周期内都可以获取到</span></span><br><span class="line">            attributes.put(TOKEN, queryMap.get(TOKEN));</span><br><span class="line">            attributes.put(CHANNEL_ID, queryMap.get(CHANNEL_ID));</span><br><span class="line">          <span class="comment">// 校验成功返回true，失败返回false，拒绝连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, String&gt; <span class="title">mapQueryString</span><span class="params">(String queryString)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(queryString)) &#123;</span><br><span class="line">            <span class="keyword">return</span> paramMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String[] kvArray = queryString.split(<span class="string">"&amp;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String kv : kvArray) &#123;</span><br><span class="line">            <span class="keyword">final</span> String[] kvPair = kv.split(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">if</span> (kvPair.length != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String key = kvPair[<span class="number">0</span>];</span><br><span class="line">            String value = kvPair[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(key) &amp;&amp; StringUtils.isNotEmpty(value)) &#123;</span><br><span class="line">                paramMap.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paramMap;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandshake</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServerHttpRequest serverHttpRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">      ServerHttpResponse serverHttpResponse, </span></span></span><br><span class="line"><span class="function"><span class="params">      WebSocketHandler webSocketHandler, </span></span></span><br><span class="line"><span class="function"><span class="params">      Exception e)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// 握手之后调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息处理器"><a href="#消息处理器" class="headerlink" title="消息处理器"></a>消息处理器</h3><p>消息处理器是ws服务的核心处理器，客户端发送来的消息都会进来进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">消息处理器，用处接收来自客户端的请求</span></span><br><span class="line"><span class="comment">需要继承AbstractWebSocketHandler这个抽象类来实现自己的自定义消息处理器</span></span><br><span class="line"><span class="comment">TextWebSocketHandler是用于处理文本消息处理器，也是AbstractWebSocketHandler的派生类</span></span><br><span class="line"><span class="comment">将CustomWebSocketHandler注册成spring的一个Bean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWebSocketHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> WsSessionManager wsSessionManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object channelId = session.getAttributes().get(CustomHandshakeInterceptor.CHANNEL_ID);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(channelId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ID获取异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object wsTmpToken = session.getAttributes().get(CustomHandshakeInterceptor.TOKEN);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(wsTmpToken)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"认证token丢失"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 托管session</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> addSuccess = wsSessionManager.add(channelId.toString(), session);</span><br><span class="line">        <span class="keyword">if</span> (!addSuccess) &#123;</span><br><span class="line">            session.close(CloseStatus.NORMAL.withReason(<span class="string">"频道被占用，请更换频道"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 来自客户端的消息在此处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"客户端消息: &#123;&#125;"</span>, message.getPayload());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在连接断后后会调用该方法进行回收处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object channelId = session.getAttributes().get(CustomHandshakeInterceptor.CHANNEL_ID);</span><br><span class="line">        log.info(<span class="string">"断开客户端连接:channelId=&#123;&#125;"</span>, channelId);</span><br><span class="line">        <span class="comment">// 移除session</span></span><br><span class="line">        wsSessionManager.remove(channelId.toString());</span><br><span class="line">        log.info(<span class="string">"Session移除成功:channelId=&#123;&#125;"</span>, channelId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session管理器"><a href="#Session管理器" class="headerlink" title="Session管理器"></a>Session管理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Session管理器，用于管理session，并注册成spring的一个Bean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsSessionManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用ConcurrentHashMap在多线程修改时保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, WebSocketSession&gt; </span><br><span class="line">      SESSION_POOL = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 托管连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String id, WebSocketSession session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> WebSocketSession oldSession = get(id);</span><br><span class="line">        <span class="keyword">if</span> (oldSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldSession.isOpen()) &#123;</span><br><span class="line">              <span class="comment">// 同频道的连接存在并且活跃的状态的话，托管失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  移除失效的的老连接</span></span><br><span class="line">            remove(id);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 加入Map容器进行托管</span></span><br><span class="line">        SESSION_POOL.put(id, session);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketSession <span class="title">get</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SESSION_POOL.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketSession <span class="title">remove</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从Map容器中移除</span></span><br><span class="line">        <span class="keyword">final</span> WebSocketSession session = SESSION_POOL.remove(id);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span> &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 移除后关闭连接</span></span><br><span class="line">                session.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.error(String.format(<span class="string">"Session关闭异常, channelId=%s"</span>, id), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置WS"><a href="#配置WS" class="headerlink" title="配置WS"></a>配置WS</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一个配置Bean，实现了WebSocketConfigurer接口</span></span><br><span class="line"><span class="comment">使用@Configuration注解将该类注册成一个配置类</span></span><br><span class="line"><span class="comment">使用@EnableWebSocket开启WebSocket自动配置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注入握手拦截器</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomHandshakeInterceptor customHandshakeInterceptor;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 注入消息处理器</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> CustomWebSocketHandler customWebSocketHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 注册消息处理器，并使用 "/channel"作为处理器的标识，客户端连接路径使用"/channel"就把请求发送给指定的处理器</span></span><br><span class="line">        registry.addHandler(customWebSocketHandler, <span class="string">"/channel"</span>) </span><br><span class="line">                .addInterceptors(customHandshakeInterceptor) <span class="comment">// 注册拦截器</span></span><br><span class="line">                .setAllowedOrigins(<span class="string">"*"</span>); <span class="comment">// 允许跨域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此基本的ws服务搭建完成。启动服务，使用客户端连接使用</p><p>提供一个简单的前端代码，通过控制台简单使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"token"</span> <span class="attr">id</span>=<span class="string">"token"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"channelId"</span> <span class="attr">id</span>=<span class="string">"channelId"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"连接"</span> <span class="attr">onclick</span>=<span class="string">"link()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"关闭"</span> <span class="attr">onclick</span>=<span class="string">"close()"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> ws</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> timer</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">link</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> token = <span class="built_in">document</span>.getElementById(<span class="string">"token"</span>).value</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> channelId = <span class="built_in">document</span>.getElementById(<span class="string">"channelId"</span>).value</span></span><br><span class="line"><span class="javascript">        ws = <span class="keyword">new</span> WebSocket(<span class="string">`ws://localhost:8080/channel?token=<span class="subst">$&#123;token&#125;</span>&amp;channelId=<span class="subst">$&#123;channelId&#125;</span>`</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        ws.onopen = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"连接完成，可以发送数据"</span>);</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 固定频率发送消息保持连接在线</span></span></span><br><span class="line"><span class="javascript">            timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                ws.send(<span class="built_in">Date</span>.now())</span></span><br><span class="line">            &#125;, 10000)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        ws.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(evt)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> received_msg = evt.data;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"数据已接收..."</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(received_msg)</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        ws.onclose = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"连接已关闭..."</span>);</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        ws.onerror = <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.error(err)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (ws === <span class="literal">null</span> || ws === <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"请先连接"</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        ws.close()</span><br><span class="line">        if (!timer) &#123;</span><br><span class="line"><span class="actionscript">            alert(<span class="string">"请先连接"</span>)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        timer.clear()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实际开发中ws服务设计需要注意的方面"><a href="#实际开发中ws服务设计需要注意的方面" class="headerlink" title="实际开发中ws服务设计需要注意的方面"></a>实际开发中ws服务设计需要注意的方面</h2><h3 id="业务层消息的确认机制"><a href="#业务层消息的确认机制" class="headerlink" title="业务层消息的确认机制"></a>业务层消息的确认机制</h3><p>虽然WS是基于TCP连接的通讯机制，TCP协议特性能保证传输层一定能成功发送数据。但是对于复杂业务和可靠性要求高的业务，最佳的实践是在业务层进行消息的确认。服务端对每一条消息映射一个唯一的标识，客户端在收到消息后，需要将该消息的唯一标识返回给服务端。否则服务端进行一定次数的重试推送，从而来保证消息的可靠推送。</p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><p>对于服务侧重在服务端消息推送的业务。那客户端需要随时保持对连接的监听，而长时间没有数据来往的情况下，不同的客户端和服务端实现会尝试关闭连接。所以为了保证服务端的及时推送，客户端需要和服务端保持一定频率的心跳连接。</p><ul><li>可以定时的往服务端发送消息，如果发现连接断开，则重新发起连接请求</li><li>可以服务端对客户端发送ping操作，客户端响应pong操作来实现心跳</li></ul><h3 id="分布式多实例部署的ws服务session的共享问题"><a href="#分布式多实例部署的ws服务session的共享问题" class="headerlink" title="分布式多实例部署的ws服务session的共享问题"></a>分布式多实例部署的ws服务session的共享问题</h3><p>由于ws连接的特殊性，即连接是有状态的。所以一旦连接断开后状态就消失了，下次再进行连接时和上一次的连接并不能对应上。所以平常Web开发中常用的基于序列化和反序列化机制的外部缓存对于面向长连接的ws来说是无法实现的。所以需要通过下面的几种机制来实现</p><h4 id="定向分配机制"><a href="#定向分配机制" class="headerlink" title="定向分配机制"></a>定向分配机制</h4><p>配备服务的连接注册中心，将用户和真实连接的节点进行映射。在需要向某一个指定用户推送消息时，通过连接注册中心找到当前处理当前用户连接的真实节点，然后将消息推送给处理节点，处理节点转发消息给用户。</p><p><strong>优点</strong>：推送精准，避免无效的广播开销，架构可以根据业务压力的增加进行水平的扩展，适用于大型服务架构</p><p><strong>缺点</strong>：实现复杂，需要独立开发一个分布式的连接管理中心。生产上需要高可用架构的设计</p><h4 id="MQ或总线的广播机制"><a href="#MQ或总线的广播机制" class="headerlink" title="MQ或总线的广播机制"></a>MQ或总线的广播机制</h4><p>通过MQ或Redis的消息订阅和发布机制，进行消息的广播。将ws服务节点接入到统一的MQ或者Redis中，订阅同一个主题或频道。当需要发送消息的时候，将消息广播给所有节点，节点收到广播后会去匹配当前消息的目标连接是否在本节点上。如果在本节点就进行消息推送。不在本节点就自动忽略。</p><p><strong>优点</strong>：实现简单，维护方便。架构上只需引入一个MQ或Redis中间件。适合ws服务节点规模不大的场景</p><p><strong>缺点</strong>：需要良好的代码实现，搞不好容易发生广播风暴，拖垮集群。而且一般一个用户只会连接在集群中的某一个节点，而将消息广播给每一个节点，其实是没必要的。当集群规模扩张到一定程度，当发送一个广播后，所有节点开始计算，导致集群的计算负载短时间内出现峰值。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>实际开发中，如果预测到集群规模不大的情况。可以优先考虑使用广播机制进行消息广播。但集群规模很大的情况下，考虑定向分配的架构设计。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/WebSocket</a></li><li><a href="https://cloud.tencent.com/developer/article/1530872" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1530872</a></li><li><a href="https://tools.ietf.org/html/rfc6455#section-5.2" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6455#section-5.2</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WebSocket协议详解以及WebSocket服务实现的技术总结&quot;&gt;&lt;a href=&quot;#WebSocket协议详解以及WebSocket服务实现的技术总结&quot; class=&quot;headerlink&quot; title=&quot;WebSocket协议详解以及WebSocket服务
      
    
    </summary>
    
    
      <category term="应用总结" scheme="https://blog.mufeng.tech/public/categories/%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="Spring" scheme="https://blog.mufeng.tech/public/tags/Spring/"/>
    
      <category term="WebSocket" scheme="https://blog.mufeng.tech/public/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="https://blog.mufeng.tech/public/2020/05/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://blog.mufeng.tech/public/2020/05/25/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-05-25T14:03:17.000Z</published>
    <updated>2020-06-02T09:49:37.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/06/02/RBHFrCTbui91Ltn.png" alt="HashMap源码解析文章结构"></p><h2 id="1-类结构"><a href="#1-类结构" class="headerlink" title="1. 类结构"></a>1. 类结构</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/25/LNKus7G16cgbo3X.png" alt="继承实现关系图"></p><p>上图可以看到，HashMap继承了AbstractMap，实现的接口有，Map、Cloneable、Serializable。</p><p>HasMap的核心数据类型是链表或红黑树的数组，数组和List结构一样可以实现扩容。并且有实现相对应的用于通过计算key对象的hash值定位数组索引位置的hash()方法，当数组同一位置的链表长度大于触发阈值的时候，链表会转化为红黑树，提高遍历的效率。HashMap的数据结构如下图。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/25/YmSLJGAnVx5qUsz.png" alt="HashMap核心数据结构图"></p><h3 id="1-1-内部类"><a href="#1-1-内部类" class="headerlink" title="1.1.内部类"></a>1.1.内部类</h3><h4 id="1-1-1-数据节点类型"><a href="#1-1-1-数据节点类型" class="headerlink" title="1.1.1.数据节点类型"></a>1.1.1.数据节点类型</h4><ul><li><p>Node</p><p>HashMap最基本的数据结构单元，核心的数据结构就是Node数组（Node&lt;K, V&gt; table）</p></li><li><p>TreeNode</p><p>当HashMap的核心数据结构table数组在同一个位置的链表长度，大于树化触发阈值的时候，同一个位置的链表将会变成红黑树的结构。他们的都是Map.Entry&lt;K,V&gt;的实现类</p></li></ul><h4 id="1-1-2-访问器类"><a href="#1-1-2-访问器类" class="headerlink" title="1.1.2. 访问器类"></a>1.1.2. 访问器类</h4><ul><li><p>KeySet</p><p>KeySet是提供给外部用于迭代访问Map的键的访问器类型</p></li><li><p>Values</p><p>Values是提供给外部用于迭代访问Map的值的访问器类型</p></li><li><p>EntrySet</p><p>EntrySet是提供给外部用于迭代访问Map健值对的访问器类型</p></li></ul><p>上面三个分别和下面的三个迭代器类型配合使用</p><h4 id="1-1-2-普通迭代器类型"><a href="#1-1-2-普通迭代器类型" class="headerlink" title="1.1.2. 普通迭代器类型"></a>1.1.2. 普通迭代器类型</h4><ul><li>KeyIterator</li><li>ValueIterator</li><li>EntryIterator</li></ul><p>迭代器类的主要作用是提供给HashMap的使用者可以通过循环访问的方式迭代访问HashMap的每个存放的元素。顾名思义，KeyIterator是用于迭代访问Map类型的键值，在HashMap中KeyIterator没有直接的暴露给外部调用，而是给KeySet</p><p>类内部使用，来访问Map的键。同理，valueIterator是给Values类使用的，用于迭代访问Map的值。EntryIterator是给EntrySet类提供的内部类，用于迭代访问Map的健值对。</p><h4 id="1-1-3-分割迭代器类型"><a href="#1-1-3-分割迭代器类型" class="headerlink" title="1.1.3. 分割迭代器类型"></a>1.1.3. 分割迭代器类型</h4><ul><li>KeySpliterator</li><li>ValueSpliterator</li><li>EntrySpliterator</li></ul><p>作用普通的的迭代器是相同的，但是分割迭代器是用于在多线程的情况下，同时遍历访问同一个HashMap对象。</p><h3 id="1-2-静态的类属性"><a href="#1-2-静态的类属性" class="headerlink" title="1.2. 静态的类属性"></a>1.2. 静态的类属性</h3><p><strong>桶</strong>：table数组同一个位置的一组以链表或红黑树形式存在的元素集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;    </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 默认的填充因子，当Map的实际元素个数大于当前Map的容量的0.75倍时候Map会进行扩容</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义的加载因子，没有指定的话后面会使用默认的DEFAULT_LOAD_FACTOR作为填充因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-核心方法"><a href="#1-3-核心方法" class="headerlink" title="1.3. 核心方法"></a>1.3. 核心方法</h3><h4 id="1-3-1-hash-方法"><a href="#1-3-1-hash-方法" class="headerlink" title="1.3.1. hash()方法"></a>1.3.1. hash()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于计算键的Hash值来确定存放table数组的索引位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-3-resize-方法"><a href="#1-2-3-resize-方法" class="headerlink" title="1.2.3. resize()方法"></a>1.2.3. resize()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map扩容方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  <span class="comment">// 暂存老的核心table数组</span></span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">// 老数组的容量</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="comment">// 老的扩容阈值</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 老容量的大于0的情况</span></span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 防止数组越界的处理</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老容量的两倍小于最大容量，并且老容量是大于等于默认容量的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      <span class="comment">// 新容量是老容量的2倍，扩容1倍</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 老的扩容阈值大于0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="comment">// 初始化HashMap后，没有任何元素的时候调用resize</span></span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    <span class="comment">// 使用默认容量作为新的容量</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// 计算新的扩容阈值</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">  <span class="comment">// 船新的扩容后的空table数组</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历老数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">// 取老的元素，并赋个新的e</span></span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 老数组位置赋值空指针，待GC回收内存</span></span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 只有一个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">          <span class="comment">// 将元素赋值给新数组的新的索引位置上</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 是红黑树的情况</span></span><br><span class="line">          <span class="comment">// 迁移红黑树数据</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          <span class="comment">// 链表的情况，迁移数据</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="comment">// 循环迭代链表</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-健值对存放逻辑"><a href="#2-健值对存放逻辑" class="headerlink" title="2.健值对存放逻辑"></a>2.健值对存放逻辑</h2><ol><li>判断当前容量是否触发扩容，如果大于容量的负载因子，进行扩容</li><li>通过HashMap的hash()方法取得hashCode</li><li>通过 (n -1) &amp; hashCode，获取table数组的索引位置，n为table的length</li><li>如果当前元素的位置是空的话，直接存入。</li><li>如果位置不为空，判断kv对的hash值与已存在的元素的是否相同，如果相同，则进行覆盖处理，不相同进行生成链表</li><li>如果相同位置的链表长度符合树化阈值，则将链表转化为红黑树</li></ol><h2 id="3-常用的方法源码解析"><a href="#3-常用的方法源码解析" class="headerlink" title="3.常用的方法源码解析"></a>3.常用的方法源码解析</h2><h3 id="3-1-put-方法"><a href="#3-1-put-方法" class="headerlink" title="3.1. put()方法"></a>3.1. put()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">// 如果table数组没有初始化或者为空的情况</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 进行扩容</span></span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">// 确定元素的要存放的索引位置，并取其原始的值</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 原来的位置是空的，直接新建一个新的Node来存放</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 已存在元素</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">// 比较第一个元素的hash和键是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="comment">// 相等的情况直接覆盖</span></span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">// 结构是红黑树的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      <span class="comment">// 放入树中</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 普通的链表结构，循环到链表的最后一个元素</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 新元素链接到链表的最后一个元素上</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 判断是否需要转换为红黑树</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="comment">// 结束循环</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较最后的元素，与插入的元素是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="comment">// onlyIfAbsent为false的话，用新的值取代旧的值</span></span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录结构修改次数</span></span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2. get()方法"></a>3.2. get()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">  <span class="comment">// 将table指针指向本地变量，并且定位到的数组元素的第一个不是null</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 查找的hash和第一个元素的hash相等</span></span><br><span class="line">    <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">        <span class="comment">// hash相等，key也是相等的情况下，就返回第一个元素</span></span><br><span class="line">        ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    <span class="comment">// 不是第一个节点的情况，查看下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是红黑树的情况</span></span><br><span class="line">      <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="comment">// 通过红黑树查找得到元素</span></span><br><span class="line">        <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">      <span class="comment">// 遍历链表</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 找到hash和key匹配的元素返回</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有找到元素，返回null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h2><h4 id="1-为什么默认的容量定义为16个？"><a href="#1-为什么默认的容量定义为16个？" class="headerlink" title="1. 为什么默认的容量定义为16个？"></a>1. 为什么默认的容量定义为16个？</h4><p>可以看到HashMap用于定位数组索引的方法是<code>(n -1) &amp; hash</code>，原理同十进制的取模运算。位运算直接对内存数据进行操作，不需要转成十进制，所以位运算要比取模运算的效率更高，所以HashMap在计算元素要存放在数组中的index的时候，使用位运算代替了取模运算。之所以可以做等价代替，前提是要求HashMap的容量一定要是2^n。至于为什么不是2，4，8而是16。因为2，4，8的容量太小，造成过早的扩容，而16以上32太大，浪费内存空间。</p><h4 id="2-为什么在JDK1-8之后加入红黑树数据结构？"><a href="#2-为什么在JDK1-8之后加入红黑树数据结构？" class="headerlink" title="2.为什么在JDK1.8之后加入红黑树数据结构？"></a>2.为什么在JDK1.8之后加入红黑树数据结构？</h4><p>之前是链表结构，搜索的时间复杂度是O(N)，之后的红黑树结构的搜索时间复杂度是O(logN)明显的红黑树的搜索效率更高。</p><h4 id="3-为什么使用与运算-n-1-amp-has代替常规的百分号取模运算？"><a href="#3-为什么使用与运算-n-1-amp-has代替常规的百分号取模运算？" class="headerlink" title="3.为什么使用与运算(n - 1) &amp; has代替常规的百分号取模运算？"></a>3.为什么使用与运算(n - 1) &amp; has代替常规的百分号取模运算？</h4><p>在上面的问题中已经说明，为了提高运算效率，不需要再转成十进制来运算。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap" target="_blank" rel="noopener">JavaGuide</a>》</li><li><a href="https://blog.csdn.net/hollis_chuang/article/details/103452727" target="_blank" rel="noopener">https://blog.csdn.net/hollis_chuang/article/details/103452727</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap源码解析&quot;&gt;&lt;a href=&quot;#HashMap源码解析&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码解析&quot;&gt;&lt;/a&gt;HashMap源码解析&lt;/h1&gt;&lt;p&gt;&lt;img src= data:image/gif;base64,R0
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://blog.mufeng.tech/public/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://blog.mufeng.tech/public/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>《算法》——排序算法总结</title>
    <link href="https://blog.mufeng.tech/public/2020/05/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.mufeng.tech/public/2020/05/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-23T06:08:47.000Z</published>
    <updated>2020-05-23T08:59:55.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《算法》——排序算法总结"><a href="#《算法》——排序算法总结" class="headerlink" title="《算法》——排序算法总结"></a>《算法》——排序算法总结</h1><h2 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/23/rcWTLyEftXjvPC5.png" alt="排序算法"></p><blockquote><p>排序算法在商业数据处理和现代科学计算中有着重要的地位，它能够应用于事物处理、组合优化、天体物理学、分子动力学、语言学、基因组学、天气预报和很多其他领域。其中一种排序算法（快速排序)甚至被誉为20世纪科学和工程领域的十大算法之一</p></blockquote><p>公用代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 后面的排序算法会实现这个接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 排序具体实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;T&gt;[] data)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较算法，v &lt; w 时返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable&lt;T&gt; v, Comparable&lt;T&gt; w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo((T)w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换元素</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable&lt;T&gt;[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable&lt;T&gt; t = data[i];</span><br><span class="line">        data[i] = data[j];</span><br><span class="line">        data[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印数组</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable&lt;T&gt;[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Comparable&lt;T&gt; i : data) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否完成排序，用于检验结果是否完成排序</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSort</span><span class="params">(Comparable&lt;T&gt;[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(data[i], data[i-<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并数组方法</span></span><br><span class="line"><span class="comment">     * [1,3,5,7,2,4,6,8] =&gt; [1,2,3,4,5,6,7,8]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aux 归并辅助数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low 需要归并的开始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 需要归并的中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high 需要归并的结束索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable&lt;T&gt;[] aux, Comparable&lt;T&gt;[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=low; k&lt;=high; k++) &#123;</span><br><span class="line">            aux[k] = data[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=low; k&lt;=high; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">                data[k] = aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; high) &#123;</span><br><span class="line">                data[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) &#123;</span><br><span class="line">                data[k] = aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                data[k] = aux[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 运行时间统计工具类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> startPoint;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> endPoint;</span><br><span class="line">    <span class="keyword">private</span> WatchState watchState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> WatchState &#123;</span><br><span class="line">        <span class="comment">// 初始化完成</span></span><br><span class="line">        init,</span><br><span class="line">        <span class="comment">// 运行中</span></span><br><span class="line">        running,</span><br><span class="line">        <span class="comment">// 停止</span></span><br><span class="line">        stop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Watch</span><span class="params">(<span class="keyword">long</span> startPoint, <span class="keyword">long</span> endPoint, WatchState watchState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startPoint = startPoint;</span><br><span class="line">        <span class="keyword">this</span>.endPoint = endPoint;</span><br><span class="line">        <span class="keyword">this</span>.watchState = watchState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Watch <span class="title">newWatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Watch(<span class="number">0</span>, <span class="number">0</span>, WatchState.init);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始计时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!WatchState.init.equals(watchState)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非重置状态，请先设置为重置状态"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.startPoint = System.currentTimeMillis();</span><br><span class="line">        watchState = WatchState.running;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 停止计时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!WatchState.running.equals(watchState)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非运行状态，无法停止"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.endPoint = System.currentTimeMillis();</span><br><span class="line">        watchState = WatchState.stop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!WatchState.stop.equals(watchState)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非停止状态，无法读取"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> timeCost = endPoint - startPoint;</span><br><span class="line">        <span class="keyword">return</span> timeUnit.convert(Duration.ofMillis(timeCost));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRead</span><span class="params">(TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = read(timeUnit);</span><br><span class="line">        System.out.println(String.format(<span class="string">"Cost: %d %s"</span>, time, timeUnit.toString().toLowerCase()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置计时器，方便复用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        startPoint = <span class="number">0</span>;</span><br><span class="line">        endPoint = <span class="number">0</span>;</span><br><span class="line">        watchState = WatchState.init;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单排序算法"><a href="#简单排序算法" class="headerlink" title="简单排序算法"></a>简单排序算法</h2><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h3><p>最简单的一种排序算法，符合正常思维，实现起来也是最简单的。时间复杂度为平方级复杂度：O(N^2)</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。</p><p>下面是示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> <span class="keyword">implements</span> <span class="title">Sort</span>&lt;<span class="title">Double</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = data.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="comment">// 此循环是找出从i个元素之后最小的元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(data[j], data[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 与最小的元素的值进行交换</span></span><br><span class="line">            exch(data, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double[] data = <span class="keyword">new</span> Double[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            data[i] = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Selection selection = <span class="keyword">new</span> Selection();</span><br><span class="line">        <span class="keyword">final</span> Watch watch = Watch.newWatch();</span><br><span class="line"></span><br><span class="line">        watch.start();</span><br><span class="line">        selection.sort(data);</span><br><span class="line">        watch.stop();</span><br><span class="line">        selection.show(data);</span><br><span class="line">        System.out.println(<span class="string">"isSort: "</span> + selection.isSort(data));</span><br><span class="line">        watch.printRead(TimeUnit.MILLISECONDS); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">isSort: true</span></span><br><span class="line"><span class="comment">Cost: 147 milliseconds，花费了147毫秒</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ul><li>运行时间与输入无关：无论输入是有序数组还是无序数组，运行的任务量是固定的。</li><li>上一次的遍历并不会给下一次的遍历提供时间收敛信息。</li><li>数据移动量最少：每次遍历最多只需要交换两个元素。</li><li>循环次数多，交换次数少（固定）</li><li>不需要额外的内存空间，在原序列上交换排序</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>数据量小，方便调用的数据序列排序时使用</p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h3><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫做插入排序。具体实现是：从左到右遍历数组，每次遍历都将左边剩余数组往右移动一位，插入相对较小元素，实现排序。</p><p>算法示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> <span class="keyword">implements</span> <span class="title">Sort</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = data.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">          <span class="comment">// 遍历索引i之前的所有元素，当后一个元素小于前一个元素的时候，交换两个元素的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(data[j], data[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">                exch(data, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double[] data = <span class="keyword">new</span> Double[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            data[i] = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Insertion insertion = <span class="keyword">new</span> Insertion();</span><br><span class="line">        <span class="keyword">final</span> Watch watch = Watch.newWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        insertion.sort(data);</span><br><span class="line">        watch.stop();</span><br><span class="line">        insertion.show(data);</span><br><span class="line">        System.out.println(<span class="string">"isSort: "</span> + insertion.isSort(data));</span><br><span class="line">        watch.printRead(TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">isSort: true</span></span><br><span class="line"><span class="comment">Cost: 274 milliseconds</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>理论上插入排序的性能要好于选择排序的，但是对于随机混乱的数组来说，插入排序的性能不如选择排序。所以在选择排序算法的时候，需要考虑输入的序列是不是随机混乱的数组。插入排序不适合大规模的均匀混乱的无序序列的排序。</p><h4 id="算法特点-1"><a href="#算法特点-1" class="headerlink" title="算法特点"></a>算法特点</h4><ul><li>插入排序算法适用于大部分为有序元素的序列，效率相较于选择排序算法，元素的交换次数明显减少。</li><li>循环次数相对固定，但交换次数明显增多（交换次数于初始序列的混乱程度有关）</li><li>插入排序所需的时间取决于输入中元素的初始顺序。如果初始序列中存在部分有序，那么通常比完全混乱的序列速度更快</li></ul><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ol><li>插入排序所需的时间取决于输入中元素的初始顺序，实际应用中对某些非随机数组很有效</li><li>小数量快速排序场景</li></ol><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h3><p>希尔排序算法是对插入排序算法的改进算法，插入排序算法存在一个问题：如果两个相邻元素在元素输入序列中相隔很远。在循环中需要花费很多次的交换操作才能排列成两个元素相邻，消耗了大量时间。而希尔排序可以跨远距离的迁移交换元素，明显减少排序的交换次数。还有一个原因是，插入排序的上一次循环的结果并不会影响下一次循环的交换量。而希尔排序的由于是跨相邻元素的排序，在上一次循环结束后，会直接减少下次循环的交换量。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。换句话说，一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组。在进行排序时，如果h很大，我们就能将元素移动到很远的地方，为实现更小的h有序创造方便</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/23/q2pVbPx5lW7yJBT.png" alt=""></p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> <span class="keyword">implements</span> <span class="title">Sort</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = data.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 选择切分步长h</span></span><br><span class="line">        <span class="keyword">while</span>( h &lt; N/<span class="number">3</span>) &#123;</span><br><span class="line">            h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(data[j], data[j-h]); j = j - h) &#123;</span><br><span class="line">                    exch(data, j, j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = (h / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double[] data = <span class="keyword">new</span> Double[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            data[i] = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Shell shell = <span class="keyword">new</span> Shell();</span><br><span class="line">        <span class="keyword">final</span> Watch watch = Watch.newWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        shell.sort(data);</span><br><span class="line">        watch.stop();</span><br><span class="line">        shell.show(data);</span><br><span class="line">        System.out.println(<span class="string">"isSort: "</span> + shell.isSort(data));</span><br><span class="line">        watch.printRead(TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法特点-2"><a href="#算法特点-2" class="headerlink" title="算法特点"></a>算法特点</h4><p>速度很快，前一次多循环会帮助后一次多循环减少交换多次数，具有收敛效应。虽然算法结构是两个嵌套的for循环，但是时间复杂度是小于O(n^2)。</p><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>适用性强，对于中等规模的数组也有很好的适用性，比插入排序具有更好的性能。通常中等大小的排序是可以接收的，属于实际开发中用的最多的排序算法。其它更加高效的算法，具有更加复杂的代码结构，但性能提升上只会比希尔排序快两倍（<strong>可能还达不到</strong>）。<strong>最佳实践是，应先考虑使用希尔排序，然后才考虑更换更加复杂的高效排序算法</strong>，因为其它高效的排序算法，往往结构都非常复杂，给程序加入不必要的复杂性往往在实践中意味项目会逐渐失去控制性。</p><h2 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h2><p>归并排序的算法与简单排序算法不同的地方是，归并排序由于需要归并操作，所以需要一块额外的内存空间用于暂存归并操作时的原始数据</p><h3 id="自顶向下归并排序"><a href="#自顶向下归并排序" class="headerlink" title="自顶向下归并排序"></a>自顶向下归并排序</h3><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>递归二分数组至不能二分，然后排序后再进行归并。核心代码是归并代码</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自顶向下归并排序算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeFromTopSort</span> <span class="keyword">implements</span> <span class="title">Sort</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable&lt;Double&gt;[] aux;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data)</span> </span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Double[data.length];</span><br><span class="line">        sort(data, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 左半函数</span></span><br><span class="line">        sort(data, low, mid);</span><br><span class="line">        <span class="comment">// 右半函数</span></span><br><span class="line">        sort(data, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">// 归并左右函数</span></span><br><span class="line">        merge(aux, data, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double[] data = <span class="keyword">new</span> Double[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            data[i] = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MergeFromTopSort mergeFromTopSort = <span class="keyword">new</span> MergeFromTopSort();</span><br><span class="line">        <span class="keyword">final</span> Watch watch = Watch.newWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        mergeFromTopSort.sort(data);</span><br><span class="line">        watch.stop();</span><br><span class="line">        mergeFromTopSort.show(data);</span><br><span class="line">        System.out.println(<span class="string">"isSort: "</span> + mergeFromTopSort.isSort(data));</span><br><span class="line">        watch.printRead(TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///运行结果</span></span><br><span class="line"><span class="comment">// isSort: true</span></span><br><span class="line"><span class="comment">// Cost: 9 milliseconds</span></span><br></pre></td></tr></table></figure><p>可以看到速度是非常快的，随机1w数组的排序时间花费了9毫秒</p><h3 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h3><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自底向上的归并算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeFromBottomSort</span> <span class="keyword">implements</span> <span class="title">Sort</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable&lt;Double&gt;[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = data.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Double[N];</span><br><span class="line">        <span class="comment">// i是间隔步长，i=1,2,4,8,16,32....</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> low=<span class="number">0</span>; low &lt; N-i; low += <span class="number">2</span>*i) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = low + i -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> high = mid + i;</span><br><span class="line">                merge(aux, data, low, mid, Math.min(high, N-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double[] data = <span class="keyword">new</span> Double[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            data[i] = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MergeFromBottomSort mergeFromBottomSort = <span class="keyword">new</span> MergeFromBottomSort();</span><br><span class="line">        <span class="keyword">final</span> Watch watch = Watch.newWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        mergeFromBottomSort.sort(data);</span><br><span class="line">        watch.stop();</span><br><span class="line">        mergeFromBottomSort.show(data);</span><br><span class="line">        System.out.println(<span class="string">"isSort: "</span> + mergeFromBottomSort.isSort(data));</span><br><span class="line">        watch.printRead(TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">// isSort: true</span></span><br><span class="line"><span class="comment">// Cost: 8 milliseconds</span></span><br></pre></td></tr></table></figure><p>随机1w数组的排序话费8毫秒</p><h2 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h2><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">implements</span> <span class="title">Sort</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data)</span> </span>&#123;</span><br><span class="line">        sort(data, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable&lt;Double&gt;[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &gt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 切分点索引</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(data, low, high);</span><br><span class="line">      <span class="comment">// 递归切分左侧</span></span><br><span class="line">        sort(data, low, j-<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 递归切分右侧</span></span><br><span class="line">        sort(data, j+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切分左右有序序列，左侧都小于j位置元素，右侧元素都大于j位置元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable&lt;Double&gt;[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="keyword">int</span> j = high + <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;Double&gt; v = data[low];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (less(data[++i], v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == high) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (less(v, data[--j])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == low) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(data, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        exch(data, low, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double[] data = <span class="keyword">new</span> Double[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            data[i] = Math.random();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> QuickSort quickSort = <span class="keyword">new</span> QuickSort();</span><br><span class="line">        <span class="keyword">final</span> Watch watch = Watch.newWatch();</span><br><span class="line">        watch.start();</span><br><span class="line">        quickSort.sort(data);</span><br><span class="line">        watch.stop();</span><br><span class="line">        quickSort.show(data);</span><br><span class="line">        System.out.println(<span class="string">"isSort: "</span> + quickSort.isSort(data));</span><br><span class="line">        watch.printRead(TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>比较次数很少</li><li>快速排序切分方法的内循环会用一个递增的索引将数组元素和一个定值比较。这种简洁性也是快速排序的一个优点。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>快速排序是最快的通用排序算法。自从数十年前快速排序发明以来，它在无数计算机系统中的无数实现已经证明了这一点。</li><li>大多数实际情况中，快速排序是最佳选择</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《<a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">算法：第4版</a>》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《算法》——排序算法总结&quot;&gt;&lt;a href=&quot;#《算法》——排序算法总结&quot; class=&quot;headerlink&quot; title=&quot;《算法》——排序算法总结&quot;&gt;&lt;/a&gt;《算法》——排序算法总结&lt;/h1&gt;&lt;h2 id=&quot;文章结构&quot;&gt;&lt;a href=&quot;#文章结构&quot; cla
      
    
    </summary>
    
    
      <category term="通用编程" scheme="https://blog.mufeng.tech/public/categories/%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://blog.mufeng.tech/public/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList容器学习总结</title>
    <link href="https://blog.mufeng.tech/public/2020/05/20/ArrayList%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.mufeng.tech/public/2020/05/20/ArrayList%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-20T06:48:26.000Z</published>
    <updated>2020-05-23T06:18:52.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList容器学习总结"><a href="#ArrayList容器学习总结" class="headerlink" title="ArrayList容器学习总结"></a>ArrayList容器学习总结</h1><h3 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/20/QwEJ3kxRnIahBz5.png" alt="ArrayList容器"></p><p>ArrayList内部的核心数据结构为Object数组，通过<code>add(T e</code>), <code>get(int index)</code>, <code>set(T e)</code>, <code>remove(int index)</code>等增删改查方法来实现对Object数组的操作。自动扩容机制也能保证ArrayList容器在使用中能够自动的适应数据容量，方便应用程序编写者的使用</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><h4 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h4><p>Object数组：Object[]</p><h4 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h4><p>AbstractList</p><h4 id="实现的接口"><a href="#实现的接口" class="headerlink" title="实现的接口"></a>实现的接口</h4><ul><li>List：支持所有的List方法</li><li>RandomAccess：可以根据数组角标进行快速的元素定位</li><li>Cloneable：可以使用<code>clone()</code>方法进行元实例的克隆</li><li>Serializable：能够实现对象的序列化</li></ul><h4 id="线程的安全性"><a href="#线程的安全性" class="headerlink" title="线程的安全性"></a>线程的安全性</h4><p>ArrayList的方法属于非线程安全性，所以要避免多个线程去修改共享ArrayList的应用场景。那么有什么可以替代的可以在多线程场景下使用的List实现类呢？目前有两个类可以代替ArrayList的多线程场景下的使用。</p><ul><li>Vector类</li><li>CopyOnWriteArrayList类</li></ul><p>Vector类是是JDK1.0版本就有用于解决有序容器的实现类，但是Vector类上用于解决线程安全方式是使用<code>synchronized</code>关键字修饰的Java同步锁。而同步的方法需要依靠JVM的协调，一个线程访问Vector代码相比于非同步的方法会话费较多的时间。在JDK1.5出来之后，在相同场景下会优先使用CopyOnWriteArrayList类。因为CopyOnWriteArrayList类对读写锁进行了优化，不锁定读操作，而对写操作时会在当前调用栈中拷贝一份原来的核心数组，在拷贝的内存上进行修改，修改结束后将原本的内存指针指向新的内存地址。由这个原理我们可以知道CopyOnWriteArrayList类在数据容量比较大的时候需要很多的时间进行数据的拷贝，所以在数据量较小的时候是属于CopyOnWriteArrayList的应用场景。</p><h3 id="ArrayList核心的算法"><a href="#ArrayList核心的算法" class="headerlink" title="ArrayList核心的算法"></a>ArrayList核心的算法</h3><h4 id="扩容算法"><a href="#扩容算法" class="headerlink" title="扩容算法"></a>扩容算法</h4><p>下面代码拷贝自JDK11的ArrayList类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容调用方法，可以看到直接调用扩容方法就是扩容当前的实际容量 size + 1</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">  <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前需要的最小的容量</span></span><br><span class="line"><span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">  <span class="comment">// 获取真实需要扩容的内部Object数组大小，并将原数组进行拷贝</span></span><br><span class="line">    <span class="keyword">return</span> elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定需要扩容的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这是扩容核心算法的核心，新的容量是 原容器容量 + 原容器容量的 * 0.5 =&gt; 也就是原容量的1.5倍</span></span><br><span class="line">  <span class="comment">// oldCapacity &gt;&gt; 1 右移动相当于 oldCapacity * 2^-1 =&gt; oldCapacity * 0.5</span></span><br><span class="line">  <span class="comment">// 这也是优化点，它这里问什么不用乘法或除法，而是用了位运算。因为jdk作为底层基础库必须考虑运行性能，而位运算的速度远远比乘除运算快</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">      <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">    ? newCapacity</span><br><span class="line">    : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">  <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">    ? Integer.MAX_VALUE</span><br><span class="line">    : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩容逻辑"><a href="#扩容逻辑" class="headerlink" title="扩容逻辑"></a>扩容逻辑</h4><p>我们可以看到上面的核心算法，每次调用grow方法都会进行数组的复制，如果每次add元素，都调用grow方法话肯定是不现实的这将会浪费大量的运算资源。</p><p>那类内部是如何扩容的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  add(e, elementData, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 我们可以看到当时间容量等于内部Object数组的长度时才会自信扩容操作</span></span><br><span class="line">  <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">    elementData = grow();</span><br><span class="line">  elementData[s] = e;</span><br><span class="line">  size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中也可以看出JDK内部为了提高运行的效率，运用了批量申请内存的思想。这与池化思想根本目的也是相同的。就是减少运算资源的消耗。这种优秀的编程思想在JDK的内部也处处可见。</p><h3 id="使用的经典案例"><a href="#使用的经典案例" class="headerlink" title="使用的经典案例"></a>使用的经典案例</h3><p>摘自《JavaGuide》ArrayList源码章节<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> list;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">         System.out.printf(<span class="string">"Before add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         arrayList.add(<span class="number">1</span>);</span><br><span class="line">         arrayList.add(<span class="number">3</span>);</span><br><span class="line">         arrayList.add(<span class="number">5</span>);</span><br><span class="line">         arrayList.add(<span class="number">7</span>);</span><br><span class="line">         arrayList.add(<span class="number">9</span>);</span><br><span class="line">         System.out.printf(<span class="string">"After add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">"Printing elements of arrayList"</span>);</span><br><span class="line">         <span class="comment">// 三种遍历方式打印元素</span></span><br><span class="line">         <span class="comment">// 第一种：通过迭代器遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过迭代器遍历:"</span>);</span><br><span class="line">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class="line">         <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">             System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种：通过索引值遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过索引值遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++)&#123;</span><br><span class="line">             System.out.print(arrayList.get(i) + <span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第三种：for循环遍历</span></span><br><span class="line">         System.out.print(<span class="string">"for循环遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(Integer number : arrayList)&#123;</span><br><span class="line">             System.out.print(number + <span class="string">" "</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// toArray用法</span></span><br><span class="line">         <span class="comment">// 第一种方式(最常用)</span></span><br><span class="line">         Integer[] integer = arrayList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种方式(容易理解)</span></span><br><span class="line">         Integer[] integer1 = <span class="keyword">new</span> Integer[arrayList.size()];</span><br><span class="line">         arrayList.toArray(integer1);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 抛出异常，java不支持向下转型</span></span><br><span class="line">         <span class="comment">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class="line">         <span class="comment">//integer2 = arrayList.toArray();</span></span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">         arrayList.add(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">         <span class="comment">// 删除指定位置上的元素</span></span><br><span class="line">         arrayList.remove(<span class="number">2</span>);    </span><br><span class="line">         <span class="comment">// 删除指定元素</span></span><br><span class="line">         arrayList.remove((Object)<span class="number">3</span>);</span><br><span class="line">         <span class="comment">// 判断arrayList是否包含5</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList contains 5 is: "</span> + arrayList.contains(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 清空ArrayList</span></span><br><span class="line">         arrayList.clear();</span><br><span class="line">         <span class="comment">// 判断ArrayList是否为空</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList is empty: "</span> + arrayList.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ArrayList的注意事项"><a href="#使用ArrayList的注意事项" class="headerlink" title="使用ArrayList的注意事项"></a>使用ArrayList的注意事项</h3><ul><li>非线程安全，切勿在夸多线程环境下修改ArrayList实例。请使用CopyOnWriteArrayList类来代替</li></ul><h3 id="ArrayList的优化手段"><a href="#ArrayList的优化手段" class="headerlink" title="ArrayList的优化手段"></a>ArrayList的优化手段</h3><ul><li><p><strong>实例化对象的时候指定数组的容量</strong></p><p>在实例化ArrayList对象的时候，构造器参数可以指定初始化的容器容量。目的是一次性申请足够的容量，避免自动扩容的时候进行无意义的数组拷贝，减少运算资源的浪费</p></li><li><p><strong>trimToSize()，减小内存占用</strong></p><p>由于扩容的机制扩容都是原容量的1.5倍，在大容量实例的ArrayList实例中内存占用会越来越大，但业务上可以预知不再增加新的元素的时候，可以使用<code>trimToSize()</code>方法使ArrayList内存占用最小化</p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList" target="_blank" rel="noopener">JavaGuide</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ArrayList容器学习总结&quot;&gt;&lt;a href=&quot;#ArrayList容器学习总结&quot; class=&quot;headerlink&quot; title=&quot;ArrayList容器学习总结&quot;&gt;&lt;/a&gt;ArrayList容器学习总结&lt;/h1&gt;&lt;h3 id=&quot;文章结构&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://blog.mufeng.tech/public/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://blog.mufeng.tech/public/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java的IO系统初步总结</title>
    <link href="https://blog.mufeng.tech/public/2020/05/17/Java%E7%9A%84IO%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.mufeng.tech/public/2020/05/17/Java%E7%9A%84IO%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%AD%A5%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-17T06:09:44.000Z</published>
    <updated>2020-05-23T06:19:03.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的IO系统初步总结"><a href="#Java的IO系统初步总结" class="headerlink" title="Java的IO系统初步总结"></a>Java的IO系统初步总结</h1><h3 id="1-文章结构"><a href="#1-文章结构" class="headerlink" title="1. 文章结构"></a>1. 文章结构</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/17/9zntoTSAMYkryip.png" alt="Java的IO总结"></p><h3 id="2-核心类"><a href="#2-核心类" class="headerlink" title="2. 核心类"></a>2. 核心类</h3><h4 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h4><p>Java的老IO系统中的类，新开发的软件请使用Path类代替File类</p><p>文件和目录的path操作工具，相当于Node.js中的Path模块，但有不限制于路径操作，在指向文件路径时又可以指代文件操作</p><p>转换为Path类型有<code>toPath()</code>方法</p><h4 id="Path类"><a href="#Path类" class="headerlink" title="Path类"></a>Path类</h4><p>与File类之间的转换，<code>toFile()</code></p><p>用于表示操作系统文件系统的文件或文件的路径。之后如果要表示路径应该优先使用Path类，如果要和老IO系统的API交互时可以使用<code>toFile()</code>方法转换为File类型</p><h4 id="FileInputStream类、FileOutputStream类"><a href="#FileInputStream类、FileOutputStream类" class="headerlink" title="FileInputStream类、FileOutputStream类"></a>FileInputStream类、FileOutputStream类</h4><p>用于文件的流的读写操作，如果要从文件系统读写文件与Java的IO系统交互就应该使用这个类。</p><p>创建从文件系统的输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FileInputStream(Path.of(<span class="string">"/Users/apple/Desktop/CharacterFileOut.txt"</span>).toFile())</span><br></pre></td></tr></table></figure><h4 id="BufferedInputStream类、BufferedOutputStream类"><a href="#BufferedInputStream类、BufferedOutputStream类" class="headerlink" title="BufferedInputStream类、BufferedOutputStream类"></a>BufferedInputStream类、BufferedOutputStream类</h4><p>带缓冲带读写流，可以在缓冲区缓冲一部分数据后在进行系统的读写调用。因为实时的读写操作需要磁盘频繁的IO操作，浪费系统资源，比较低效。而使用带缓冲区的读写可以批量的读写至缓冲区，当缓冲区满时候，批量的读出或写入到文件系统</p><p>创建带缓冲写的输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">  <span class="keyword">new</span> FileOutputStream(Path.of(<span class="string">"/Users/apple/Desktop/CharacterFileOut.txt"</span>).toFile())</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="ZipIntputStream类、ZipOutputStream类"><a href="#ZipIntputStream类、ZipOutputStream类" class="headerlink" title="ZipIntputStream类、ZipOutputStream类"></a>ZipIntputStream类、ZipOutputStream类</h4><p>用于创建压缩文件或文件夹和解压缩文件或文件夹。Gzip算法类似有GZIPInputStream、GZIPOutputStream类</p><p>使用到的中间类</p><p><code>ZipEntry</code>, <code>ZipFile</code></p><h4 id="Reader、Writer家族派生类"><a href="#Reader、Writer家族派生类" class="headerlink" title="Reader、Writer家族派生类"></a>Reader、Writer家族派生类</h4><p>用于补充传统的<code>InputStream</code>, <code>OutputStream</code>派生子类，因为这些类只能读写人不可读的字节数据。而业务开发中经常有读写字符文件数据的需要需求，而Reader，和Writer的派生之类家族就是用来简化读写字符流的类。还有一个重要的原因是老的IO流在读写字节流时候仅支持8位的字节流，而现在常用的Unicode字符是16位的。因此开发流Reader和Writer的派生类来解决字符流读写的国际化问题。</p><p>所以在业务开发过程中，如果有读写字符文件的需求，应优先使用时Reader和Writer的派生子类。</p><p>常见的子类</p><ul><li>FileReader，FileWriter：用于字符文件的读写，相对应的老IO中的<code>FileinputStream</code>和<code>FileOutputStream</code></li><li>StringReader，StringWriter：用于读写字符串类型的数据流，对应的是<code>StringBufferInputStream</code></li><li>CharArrayReader，CharArrayWriter：用于字符数组类型的读写数据流，对应的是<code>ByteArrayInputStream</code>, <code>ByteArrayOutputStream</code></li><li>BufferedReader, BufferedWriter: 用于字符类型的缓冲读写，对应<code>BufferedInputStream</code>, <code>BufferedOutputStream</code></li><li>PrintWriter: 用于数据的可视化输出，支持Java的的数据类型。和使用<code>System.out</code>的使用接口相同</li></ul><h4 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h4><p>用于执行操作系统的其它程序，比如调用Linux的<code>Shell</code>命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProcessBuilder pb = <span class="keyword">new</span> ProcessBuilder(<span class="string">"ls -ahl"</span>.split(<span class="string">" "</span>)).start();</span><br></pre></td></tr></table></figure><h3 id="3-经典的使用方式"><a href="#3-经典的使用方式" class="headerlink" title="3. 经典的使用方式"></a>3. 经典的使用方式</h3><h4 id="3-1-字符类型的文件读写"><a href="#3-1-字符类型的文件读写" class="headerlink" title="3.1.字符类型的文件读写"></a>3.1.字符类型的文件读写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterFileIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        String filename = <span class="string">"/Users/apple/Desktop/CharacterFileOut.txt"</span>;</span><br><span class="line">        writer(filename, <span class="string">"Harry Hacker: 72000\n"</span>);</span><br><span class="line">        String readResult = read(filename);</span><br><span class="line">        System.out.println(<span class="string">"ReadResult: "</span> + readResult);</span><br><span class="line">        writerSimple(filename, <span class="string">"Harry Hacker: 72001\n"</span>);</span><br><span class="line">        String readSimpleResult = readSimple(filename);</span><br><span class="line">        System.out.println(<span class="string">"readSimpleResult: "</span> + readSimpleResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Path path = Paths.get(filename);</span><br><span class="line">        <span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path.toFile(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String s;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((s = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Files类读文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readSimple</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Path path = Paths.get(filename);</span><br><span class="line">        Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        lines.forEach(i -&gt; &#123;</span><br><span class="line">            sb.append(i).append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">(String filename, CharSequence content)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        Path path = Paths.get(filename);</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(path.toFile())))) &#123;</span><br><span class="line">            printWriter.println(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Files类写文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerSimple</span><span class="params">(String filename, String content)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        Path path = Paths.get(filename);</span><br><span class="line">        Files.write(path, content.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-二进制类文件的读写"><a href="#3-2-二进制类文件的读写" class="headerlink" title="3.2. 二进制类文件的读写"></a>3.2. 二进制类文件的读写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制文件读读写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteFileIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String filepath = <span class="string">"/Users/apple/Desktop"</span>;</span><br><span class="line">        String filename = <span class="string">"ByteFileIOOut.jpg"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读</span></span><br><span class="line">        <span class="keyword">byte</span>[] readData = read(Path.of(filepath, filename).toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写</span></span><br><span class="line">        String filenameOut = <span class="string">"ByteFileIOOut2.jpg"</span>;</span><br><span class="line">        writer(Path.of(filepath, filenameOut).toString(), readData);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Files读</span></span><br><span class="line">        <span class="keyword">byte</span>[] simpleReadData = readSimple(Path.of(filepath, filename).toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Files写</span></span><br><span class="line">        String filenameSimpleOut = <span class="string">"ByteFileIOSimpleOut.jpg"</span>;</span><br><span class="line">        writerSimple(Path.of(filepath, filenameSimpleOut).toString(), simpleReadData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(String filename) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Path path = Paths.get(filename);</span><br><span class="line">        <span class="keyword">try</span>(BufferedInputStream fileIn = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(path.toFile()))) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = fileIn.available();</span><br><span class="line">            <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">            <span class="keyword">int</span> totalSize = fileIn.read(data);</span><br><span class="line">            System.out.println(<span class="string">"read "</span>+ path.getFileName() +<span class="string">" finished total size: "</span>+ totalSize +<span class="string">" bytes"</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readSimple(String filename) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Path path = Paths.get(filename);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line">        System.out.println(<span class="string">"readSimple "</span> + path.getFileName() + <span class="string">" finished total size: "</span> + bytes.length + <span class="string">" bytes"</span>);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">(String filename, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Path path = Paths.get(filename);</span><br><span class="line">        <span class="keyword">try</span>(BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(path.toFile()))) &#123;</span><br><span class="line">            out.write(data);</span><br><span class="line">            System.out.println(<span class="string">"writer "</span> + path.getFileName() + <span class="string">" finished total size: "</span> + data.length + <span class="string">" bytes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerSimple</span><span class="params">(String filename, <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Path path = Paths.get(filename);</span><br><span class="line">        Files.write(path, data);</span><br><span class="line">        System.out.println(<span class="string">"writerSimple "</span> + path.getFileName() + <span class="string">" finished total size: "</span> + data.length + <span class="string">" bytes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">read ByteFileIOOut.jpg finished total size: 200960 bytes</span></span><br><span class="line"><span class="comment">writer ByteFileIOOut2.jpg finished total size: 200960 bytes</span></span><br><span class="line"><span class="comment">readSimple ByteFileIOOut.jpg finished total size: 200960 bytes</span></span><br><span class="line"><span class="comment">writerSimple ByteFileIOSimpleOut.jpg finished total size: 200960 bytes</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-3-文件或文件夹的压缩和解压缩"><a href="#3-3-文件或文件夹的压缩和解压缩" class="headerlink" title="3.3. 文件或文件夹的压缩和解压缩"></a>3.3. 文件或文件夹的压缩和解压缩</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZipFileIO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, IllegalAccessException </span>&#123;</span><br><span class="line">        <span class="comment">// 压缩测试</span></span><br><span class="line">        System.out.println(<span class="string">"=======运行压缩======="</span>);</span><br><span class="line">        zip(Path.of(<span class="string">"/Users/apple/Desktop/python数据分析与机器学习实战"</span>), Path.of(<span class="string">"/Users/apple/Desktop/python数据分析与机器学习实战.bak.zip"</span>));</span><br><span class="line">        <span class="comment">// 解压测试</span></span><br><span class="line">        System.out.println(<span class="string">"=======运行解压======="</span>);</span><br><span class="line">        unZip(Path.of(<span class="string">"/Users/apple/Desktop/python数据分析与机器学习实战.bak.zip"</span>), Path.of(<span class="string">"/Users/apple/Desktop/1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zip</span><span class="params">(Path sourcePath, Path targetPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File sourceFile = sourcePath.toFile();</span><br><span class="line">        <span class="keyword">final</span> File targetFile = targetPath.toFile();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="keyword">final</span> ZipOutputStream zipOut = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(targetFile)));</span><br><span class="line">        ) &#123;</span><br><span class="line">            compress(zipOut, sourceFile, sourceFile.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">(ZipOutputStream zipOut, File source, String sourceName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isDir = source.isDirectory();</span><br><span class="line">        <span class="keyword">if</span> (!isDir) &#123;</span><br><span class="line">            System.out.println(sourceName);</span><br><span class="line">            zipOut.putNextEntry(<span class="keyword">new</span> ZipEntry(sourceName));</span><br><span class="line">            <span class="keyword">try</span> (BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(source));) &#123;</span><br><span class="line">                <span class="keyword">int</span> b;</span><br><span class="line">                <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    zipOut.write(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 目录</span></span><br><span class="line">            File[] files = source.listFiles();</span><br><span class="line">            <span class="keyword">if</span> (files == <span class="keyword">null</span> || files.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                zipOut.putNextEntry(<span class="keyword">new</span> ZipEntry(Path.of(sourceName, <span class="string">""</span>).toString()));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                    <span class="keyword">final</span> String nextFilename = Path.of(sourceName, file.getName()).toString();</span><br><span class="line">                    compress(zipOut, file, nextFilename);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZip</span><span class="params">(Path sourcePath, Path targetPath)</span> <span class="keyword">throws</span> IllegalAccessException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File sourceFile = sourcePath.toFile();</span><br><span class="line">        <span class="keyword">if</span> (!sourceFile.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(sourceFile.toString() + <span class="string">" not exist"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(sourcePath.toFile());</span><br><span class="line">        <span class="keyword">final</span> Enumeration&lt;? extends ZipEntry&gt; entries = zipFile.entries();</span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">final</span> ZipEntry zipEntry = entries.nextElement();</span><br><span class="line">            System.out.println(zipEntry.getName());</span><br><span class="line">            <span class="keyword">if</span> (zipEntry.isDirectory()) &#123;</span><br><span class="line">                Paths.get(targetPath.toString(), zipEntry.getName()).toFile().mkdirs();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> File zipEntryFile = Paths.get(targetPath.toString(), zipEntry.getName()).toFile();</span><br><span class="line">                <span class="keyword">final</span> File parentFile = zipEntryFile.getParentFile();</span><br><span class="line">                <span class="keyword">if</span> (!parentFile.exists()) &#123;</span><br><span class="line">                    parentFile.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                zipEntryFile.createNewFile();</span><br><span class="line">                <span class="keyword">try</span>(</span><br><span class="line">                        <span class="keyword">final</span> BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(zipFile.getInputStream(zipEntry));</span><br><span class="line">                        <span class="keyword">final</span> BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(zipEntryFile))</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> b;</span><br><span class="line">                    <span class="keyword">while</span> ((b = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Java的IO类的使用原则"><a href="#4-Java的IO类的使用原则" class="headerlink" title="4. Java的IO类的使用原则"></a>4. Java的IO类的使用原则</h3><p>IO类库的设计使用的是<strong>装饰器模式</strong></p><p>比如要读取一个二进制文件，那么可以确定需要使用Input类型的类，比如从文件系统读取，那需要<code>FileInputStream</code>类。而且希望能够高效的读取，减少系统开销。所以需要使用缓冲区功能，那需要<code>BufferedInputStream</code>类。</p><p>那应该如何将用到的两个类组合起来使用呢？ 通过嵌套流过滤器来实现，通过组合不同功能的流过滤器来实现不同功能的数据流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file))</span><br></pre></td></tr></table></figure><p>这种通过多个流过滤器的组合起来使用的方式，将带来极大的灵活性。但是灵活性、易用性这两个方面想都完美是不可能的。这就涉及到取舍了，二Java就选择了前者。但是随着JDK的新版本出来，只目前的新版本中也出现了高封装成都的IO类，比如从JDk1.7引入的<code>Files</code>类，就包含很多简单的读写封装</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://book.douban.com/subject/26880667/" target="_blank" rel="noopener">《Java核心技术：卷1》</a></p><p><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Thinking in Java》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java的IO系统初步总结&quot;&gt;&lt;a href=&quot;#Java的IO系统初步总结&quot; class=&quot;headerlink&quot; title=&quot;Java的IO系统初步总结&quot;&gt;&lt;/a&gt;Java的IO系统初步总结&lt;/h1&gt;&lt;h3 id=&quot;1-文章结构&quot;&gt;&lt;a href=&quot;#1-文
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://blog.mufeng.tech/public/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://blog.mufeng.tech/public/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射学习记录</title>
    <link href="https://blog.mufeng.tech/public/2020/05/13/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.mufeng.tech/public/2020/05/13/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2020-05-13T03:38:32.000Z</published>
    <updated>2020-06-02T09:51:52.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java反射学习记录"><a href="#Java反射学习记录" class="headerlink" title="Java反射学习记录"></a>Java反射学习记录</h1><h3 id="1-文章结构"><a href="#1-文章结构" class="headerlink" title="1. 文章结构"></a>1. 文章结构</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://i.loli.net/2020/05/26/vblkX6NYjFLBH3h.png" alt="Java的反射机制.png"></p><h3 id="2-反射是什么？"><a href="#2-反射是什么？" class="headerlink" title="2. 反射是什么？"></a>2. 反射是什么？</h3><p>反射是提供了能够动态操作Java代码的工具集程序。有一下几种能力</p><ol><li>在运行时分析类的能力</li><li>在运行时查看对象</li><li>实现通用的数组操作代码<br>参考：《<a href="https://book.douban.com/subject/26880667/" target="_blank" rel="noopener">Java核心技术：卷1</a>》第190页-反射章节</li></ol><p>下面的简单的反射代码例子可以感受一下（摘取自《<a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Thinking in Java</a>》反射章节）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"My name is "</span> + name + <span class="string">" and "</span> + age +<span class="string">" years old"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String usage = <span class="string">"usage: \n"</span>+</span><br><span class="line">    <span class="string">"ShowMethods qualified.class.name\n"</span>+</span><br><span class="line">    <span class="string">"To Show all methods in class or:"</span> +</span><br><span class="line">    <span class="string">"ShowMethods qualified.class.name word\n"</span> +</span><br><span class="line">    <span class="string">"To search for methods involving word"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern pattern = Pattern.compile(<span class="string">"\\w+\\."</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(usage);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lines = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            Method[] methods = c.getMethods();</span><br><span class="line">            c.getMethod(name, parameterTypes)</span><br><span class="line">            Constructor[] ctors = c.getConstructors();</span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"===========下面是方法==========="</span>);</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    System.out.println(pattern.matcher(method.toString()).replaceAll(<span class="string">""</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"===========下面是构造器==========="</span>);</span><br><span class="line">                <span class="keyword">for</span>(Constructor ctor : ctors) &#123;</span><br><span class="line">                    System.out.println(pattern.matcher(ctor.toString()).replaceAll(<span class="string">""</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                lines = methods.length + ctors.length;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"===========下面是方法==========="</span>);</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (method.toString().indexOf(args[<span class="number">1</span>]) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(pattern.matcher(method.toString()).replaceAll(<span class="string">""</span>));</span><br><span class="line">                        lines++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"===========下面是构造器==========="</span>);</span><br><span class="line">                <span class="keyword">for</span>(Constructor ctor : ctors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ctor.toString().indexOf(args[<span class="number">1</span>]) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(pattern.matcher(ctor.toString()).replaceAll(<span class="string">""</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    lines++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"No such class: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反射的应用"><a href="#3-反射的应用" class="headerlink" title="3. 反射的应用"></a>3. 反射的应用</h3><p>反射在平时的业务开发中其实自己去实现的频率并不高，更多的是用注解的形式去使用反射机制，而且大部分开发常用的注解都框架都已经实现，只有很少部分都注解需要自己去实现。如果你学习偏向于业务程序的开发，而不是库的开发。可以选择性的学习反射的相关知识。</p><p>有如下的应用：</p><ol><li>用于自定义注解的读取</li><li>外部的包和库没有源码的时候，可以用反射的方式去间接的查看类的定义</li><li>工具，库，框架的开发过程中经常使用</li></ol><h3 id="4-反射中常用到的中间类以及类上面的方法"><a href="#4-反射中常用到的中间类以及类上面的方法" class="headerlink" title="4. 反射中常用到的中间类以及类上面的方法"></a>4. 反射中常用到的中间类以及类上面的方法</h3><p>使用反射常见的过程是：</p><ol><li>获取目标对象</li><li>功过getClass()方法获取改对象实例的Class类</li><li>在Class上通过getDeclaredFields()，getDeclaredMethods(), getConstructor()等方法获取你感兴趣的部分</li><li>通过getName()获取目标部分定义的名字，Field.getType()获取定义的类型等</li><li>通过获取到感兴趣的类结构信息后将信息做相对应的处理</li></ol><h4 id="4-1-Construct对象"><a href="#4-1-Construct对象" class="headerlink" title="4.1. Construct对象"></a>4.1. Construct对象</h4><p>使用反射的第一个入口就是获取实例对象的Class类对象。</p><p>class.getContructs()获取构造器列表</p><h4 id="4-2-Method对象"><a href="#4-2-Method对象" class="headerlink" title="4.2 Method对象"></a>4.2 Method对象</h4><p>class.getMethods()和class.getDeclaredmethods()可以获取改类上面的定义的方法，类上定义的方法等类型是Method对象</p><p>getMetheds() 和 getDeclaredMethods()的区别是，前者只会返回权限修饰符是public的方法，而后者是访问类上定义的所有的方法，但不包括父类上面的方法。</p><h4 id="4-3-Field对象"><a href="#4-3-Field对象" class="headerlink" title="4.3. Field对象"></a>4.3. Field对象</h4><p>class.getFields()或class.getDeclaredFields()。返回类上定义的属性列表。两者却别和上面相同。通过Field对象我们可以访问到类上属性的定义</p><p>Field.getType()方法可以获取改域定义的数据类型</p><h4 id="4-4-Modifier对象"><a href="#4-4-Modifier对象" class="headerlink" title="4.4. Modifier对象"></a>4.4. Modifier对象</h4><p>此对象为访问修饰符对象，常用的静态方法是<code>toString(int modifiers)</code>，返回构造器，域，方法上的访问修饰符的字符串形式。在构造器，域，方法上获取访问修饰符的通用方法是getModifiers()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> modifiers = Class.getMethods()[<span class="number">0</span>].getModifiers();</span><br><span class="line">Modifier.toString(modifiers); <span class="comment">// =&gt; "public final"之类的</span></span><br></pre></td></tr></table></figure><p>还是有 isPublic(), isPrivate()，。。。。以此类推。</p><h4 id="4-4-Construct，Field，Method上的通用方法"><a href="#4-4-Construct，Field，Method上的通用方法" class="headerlink" title="4.4. Construct，Field，Method上的通用方法"></a>4.4. Construct，Field，Method上的通用方法</h4><ul><li>getName()方法，此方法可以获取定义的对象的代码名字字符串。</li><li>getModifiers()方法，获取访问修饰符</li></ul><h3 id="5-使用案例"><a href="#5-使用案例" class="headerlink" title="5. 使用案例"></a>5. 使用案例</h3><p><a href="https://www.bilibili.com/read/cv4802402" target="_blank" rel="noopener">参考原文</a></p><p>需求描述：定义一个注解 <code>@Length(int min, int max, String message)</code>用在类的字符串属性上，定义该字符串的长度在定义的范围内。</p><h4 id="5-1-第一步：先定义注解"><a href="#5-1-第一步：先定义注解" class="headerlink" title="5.1. 第一步：先定义注解"></a>5.1. 第一步：先定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.Field &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Length &#123;</span><br><span class="line">  <span class="keyword">int</span> min;</span><br><span class="line">  <span class="keyword">int</span> max;</span><br><span class="line">  String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是用在类属性上，所以注解的的@Target元注解为Field，还有因为注解需要在运行时被读取，所以@Retention元注解要为runtime。</p><h4 id="5-2-第二步：获取注解并进行验证"><a href="#5-2-第二步：获取注解并进行验证" class="headerlink" title="5.2.  第二步：获取注解并进行验证"></a>5.2.  第二步：获取注解并进行验证</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">validate</span><span class="params">(Object target)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="comment">// 为了方便演示，健壮性代码就不写了</span></span><br><span class="line">  Field[] declaredFields = target.getClass().getDeclaredFields();</span><br><span class="line">  <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLengthAnnotation = field.isAnnotationPresent(Length<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLengthAnnotation) &#123;</span><br><span class="line">      Length length = field.getAnnotation(Length<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 为了也能够获取访问修饰符不为public的属性的值</span></span><br><span class="line">      <span class="keyword">int</span> valueActuallyLength = ((String)field.get(target)).length();</span><br><span class="line">      <span class="keyword">if</span> (valueActuallyLength &lt; length.min() || valueActuallyLength &gt; length.max()) &#123;</span><br><span class="line">        <span class="keyword">return</span> length.message();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://book.douban.com/subject/26880667/" target="_blank" rel="noopener">《Java核心技术：卷1》</a></p></li><li><p><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Thinking in Java》</a></p></li><li><p><a href="https://www.bilibili.com/read/cv4802402" target="_blank" rel="noopener"> 注解案例</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java反射学习记录&quot;&gt;&lt;a href=&quot;#Java反射学习记录&quot; class=&quot;headerlink&quot; title=&quot;Java反射学习记录&quot;&gt;&lt;/a&gt;Java反射学习记录&lt;/h1&gt;&lt;h3 id=&quot;1-文章结构&quot;&gt;&lt;a href=&quot;#1-文章结构&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://blog.mufeng.tech/public/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://blog.mufeng.tech/public/tags/Java/"/>
    
  </entry>
  
</feed>
